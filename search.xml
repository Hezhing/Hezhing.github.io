<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[（一）环境配置]]></title>
    <url>%2F2018%2F10%2F03%2F%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F%EF%BC%88%E4%B8%80%EF%BC%89%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[歌单推荐]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%AD%8C%E5%8D%95%E6%8E%A8%E8%8D%90%2F%E6%AD%8C%E5%8D%95%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[[20181003]歌名歌手推荐理由优美歌词摘抄生命中的时光 链接 齐一 齐一不便多说，第一次听到他的声音，是那首《这个年纪》，苍翠有力，活泼俏皮，当时没少单曲循环。今日首推这首歌，作词作曲皆为上品，“想要把自己活成一场梦，一首歌一部电影。”已经折服了我。少不了励志词语，”每天醒来的时候照照镜子，用一个微笑补偿自己”。让人不禁感叹，生命中那些难熬的时光，终将会在某一天找到所有孤独的意义。 在只有凌晨才不会太拥挤的城市我披星戴月独自穿行 想要把自己活成一场梦一首歌一部电影就算会半梦半醒就算压（押）不上韵却还是期待所有故事结局 我会在每天醒来的时候照照镜子用一个微笑补偿自己生活太不容易却仍不甘心问问自己是否拼尽全力 我也佩服我的勇气也心疼所有孤独的意义 [20181004]歌名歌手推荐理由优美歌词摘抄这个年纪 链接 齐一 这是我听的齐一的第一首歌，当时我是高三，正值年少，资历尚且，无法听出歌中的无助和难以为继。齐一当时年过三十，缺乏了我这个年纪的冲动，多了一丝成熟稳重，从他口中唱出的词多了一丝岁月的韵味，可能就是那一句话，该来的总会来该走的也无法挽留折服了我。如今再看，没了一些东西，又有了一些东西。或许当我年过三十再回首，可能会感叹，这就是生活吧。 当我习惯把实话都变成了童话那我的单纯呢 那我的单纯呢这个年纪我已不再将就有些事情无法强求该来的总会来该走的也无法挽留 [20181005]歌名歌手推荐理由优美歌词摘抄只只 链接 孟凡明 以前从未听过他的歌。遇到这首歌纯属意外。初感是一首写给另一半的歌曲，用词相比之前所听又没许多。作曲相对平缓很多，不像其他歌曲时而沉浮时而激烈，“十月过后的天空，醉酒般晕红”，初听时并不觉有多好听，但越听越觉有味。可能这就是平淡的喜欢一个人的感觉。把两个相恋的人的日常写的平淡无奇，却唱的深沉浓烈。 在山野间追风，去看遍世界黄昏与黎明 任时间过往匆匆，轻易就远去无声在人潮之中，想要拥抱你，哪怕片刻永恒我已经偷偷决定，把爱你的事澄清在百念之中，你依然是我，未寻得的旧梦 [20181009]歌名歌手推荐理由优美歌词摘抄可能否 链接 木小雅 不知怎说这首歌，经历过的自然懂的，不撞南墙不回头，不见黄河不死心。人生可能就需要这样的一股子劲，逼着自己，向前冲，管他对与错，管他是与非，管他谁是谁，可能多年之后，南墙撞到了，再不会出现，黄河干了，再不会出现，绝望不见了，成了美好的回忆。但这一起，均是可能否。 可能我撞了南墙才会回头吧可能我见了黄河才会死心吧可能我偏要一条路走到黑吧可能我还没遇见，那个他吧 春天的风 能否吹来夏天的雨秋天的月 能否照亮冬天的雪夜空的星 能否落向晨曦的海山间的泉 能否遇上南飞的雁断掉的弦 能否扯破自缚的茧熄灭的火 能否烧光残留的念梦中的云 能否化作熟悉的脸前世的劫 能否换来今生的缘 能否早一点 看透命运的伏线能否慢一点 挥霍有限的时间能否早一点 相信年少的誓言能否慢一点 感受岁月的缱绻]]></content>
      <categories>
        <category>歌单</category>
      </categories>
      <tags>
        <tag>歌单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Scrapy框架遇到的问题]]></title>
    <url>%2F2018%2F08%2F28%2FScrapy%E7%88%AC%E8%99%AB%2FWindows%E4%B8%8B%E5%AE%89%E8%A3%85Scrapy%E6%A1%86%E6%9E%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[##遇见如下错误： error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools” ##解决办法如下： 一般按照提示是需要安装一个C++14.0的一个库，但是进入网址后，此库总的有4G这么大，下载安装肯定不现实，好在在这里有文件，可以先行下载。不过是个国外网站，如果可以翻墙，那就美滋滋了。下载的文件为这个： 然后执行操作为：然后再次执行操作：pip install Scrapy]]></content>
      <categories>
        <category>-解决问题</category>
      </categories>
      <tags>
        <tag>-问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swust oj数据结构前40题中的20个python实现]]></title>
    <url>%2F2018%2F08%2F02%2Fswust-oj%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D40%E9%A2%98%E4%B8%AD%E7%9A%8420%E4%B8%AApython%E5%AE%9E%E7%8E%B0%2Fswust-oj%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D40%E9%A2%98%E4%B8%AD%E7%9A%8420%E4%B8%AApython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[#注意：学校oj python所用的是python2，用python3交会报CE 不要问我怎么知道的，当你有满屏CE的时候，你会知道的。 [941] 有序顺序表的合并操作的实现思路题目描述python代码实现数据结构实现比较a列表和b列表的大小，然后按顺序放到 c列表里 传送门 描述 已知两非递减的顺序线性表，要求合并成一个新的非递减顺序线性表。(测试数据为整型) 输入 输入包含四行，第一行为自然数n，表示第一个非递减顺序线性表的长度;第二行为n个自然数构成的非递减顺序线性表;第三行为自然数m，表示第二个非递减顺序线性表的长度;第四行为m个自然数构成的非递减顺序线性表 输出 用一行输出合并后的非递减顺序线性表，各数之间用一个空格隔开。 样例输入123421 332 3 6 样例输出11 2 3 3 6 1234567891011121314151617181920212223242526272829303132a = []n1 = int(input())a = list(map(int,raw_input().split()))b = []n2 = int(input())b = list(map(int,raw_input().split()))len_a = len(a)len_b = len(b)la, lb = 0, 0c = []while la &lt; len_a and lb &lt; len_b: if a[la] &lt; b[lb]: c.append(a[la]) la += 1 else: c.append(b[lb]) lb += 1while la &lt; len_a: c.append(a[la]) la += 1while lb &lt; len_b: c.append(b[lb]) lb += 1for i in range(la + lb): print c[i], 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct&#123; elemtype data[500]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist )malloc(sizeof(sqlist)); L-&gt;length=0; &#125; void creatlist(sqlist &amp;L,elemtype a[],int n)&#123; int i=0; for(i=0;i&lt;n;i++) &#123; L-&gt;data[i]=a[i]; &#125; L-&gt;length=n;&#125;void desplist(sqlist L)&#123; int i; printf(“%d”,L-&gt;data[0]); for(i=1;i&lt; L-&gt;length;i++) &#123; printf(“ %d”,L-&gt;data[i]); &#125; printf(“\n”);&#125;void Combine(sqlist &amp;la,sqlist &amp;lb,sqlist &amp;lc)&#123; int i=0,j=0,k=0; while(i&lt;la-&gt;length&amp;&amp;j&lt;lb-&gt;length) &#123; if(la-&gt;data[i]&lt;=lb-&gt;data[j]) &#123; lc-&gt;data[k]=la-&gt;data[i]; k++;i++; &#125; else &#123; lc-&gt;data[k]=lb-&gt;data[j]; k++;j++; &#125; &#125; while(i&lt;la-&gt;length) &#123; lc-&gt;data[k]=la-&gt;data[i]; k++;i++; &#125; while(j&lt;lb-&gt;length) &#123; lc-&gt;data[k]=lb-&gt;data[j]; k++;j++; &#125; lc-&gt;length=k;&#125;int main()&#123; sqlist la; sqlist lb; sqlist lc; int a[1000],b[1000]; int n,m; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); scanf(“%d”,&amp;m); for(int j=0;j&lt;m;j++) scanf(“%d”,&amp;b[j]); initlist(la); initlist(lb); initlist(lc); creatlist(la,a,n); creatlist(lb,b,m); Combine(la,lb,lc); desplist(lc); return 0;&#125; [942] 逆置顺序表思路题目描述python代码实现数据结构实现… 传送门 描述 建立长度为n的顺序表，然后将表中的数据元素逆置，即若表中原来的数据元素序列为（a0，a1，a2，…，an），则逆置后的数据元素序列为（an，an-1，an-2，…，a1，a0）。（数据类型为字符型） 输入 第一行为顺序表的长度n；第二行为顺序表中的数据元素. 输出 输出为逆置后的顺序表. 样例输入127ABCDEFG 样例输出1G F E D C B A 123456789101112try: while True: #循环 n=int (input()) a = [] d = 0 for x in raw_input(): a.append(x) d = d+1 for i in range(d-1,-1,-1): print a[i],except EOFError: exit() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char ElemType;typedef struct&#123; ElemType data[5000]; int length; &#125;SqList;void InitList(SqList &amp;L)&#123; L=(SqList)malloc(sizeof(SqList)); L-&gt;length=0; &#125; void CreatList(SqList &amp;L,char a[],int n)&#123; int i=0,k=0; while(i&lt;n) &#123; L-&gt;data[i]=a[i]; i++;k++; &#125; L-&gt;length=k;&#125;void DispList(SqList L)&#123; printf(“%c”,L-&gt;data[L-&gt;length-1]); for(int i=L-&gt;length-2;i&gt;=0;i–) printf(“ %c”,L-&gt;data[i]); printf(“\n”);&#125;int main()&#123; int n; char a[1000]; SqList *q; scanf(“%d”,&amp;n); getchar(); for(int i=0;i&lt;n;i++) &#123; scanf(“%c”,&amp;a[i]); &#125; InitList(q); CreatList(q,a,n); DispList(q); return 0;&#125; [943] 顺序表插入操作的实现思路题目描述python代码实现数据结构实现插入。。 传送门 描述 建立长度为n的顺序表，在指定的数据元素item之前插入数据元素data。如果指定的数据元素item不存在，则将data插入到顺序表的尾端。（数据类型为整型） 输入 第一行为顺序表的长度n；第二行为顺序表中的数据元素；第三行为指定的数据元素item；第四行为要插入的数据元素data； 输出 输出结果为顺序表中的数据元素。 样例输入12341010 20 30 40 50 60 70 80 90 1005055 样例输出110 20 30 40 55 50 60 70 80 90 100 1234567891011121314151617181920212223a = []n = int(input())a = list(map(int , raw_input().split()))x = int(input())y = int(input())k = -1def Findx(a,x): for i in range(len(a)): if(x == a[i]): global k #定义外部的k k = i return True return Falseif Findx(a,x) == True: a.insert(k,y) #根据下标插入else: a.append(y)for i in range(len(a)): print a[i], 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct&#123; elemtype data[1000]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist)malloc(sizeof(sqlist)); L-&gt;length=0;&#125;void creatlist(sqlist &amp;L,elemtype a[],int n)&#123; int i=0; while(i&lt;n) &#123; L-&gt;data[i]=a[i]; i++; &#125; L-&gt;length=n;&#125;void desplist(sqlist L)&#123; int i; //L-&gt;length++; printf(“%d”,L-&gt;data[0]); for(i=1;i&lt;=L-&gt;length;i++) &#123; printf(“ %d”,L-&gt;data[i]); &#125; printf(“\n”);&#125;void insertlist(sqlist &amp;L,elemtype x,int y)&#123; int z=0,i,k; for(i=0;i&lt;L-&gt;length;i++) &#123; if(x==L-&gt;data[i]) &#123; z=1; k=i; break; &#125; &#125; if(z==0) &#123; L-&gt;data[L-&gt;length]=y; &#125; else &#123; for(int j=L-&gt;length-1;j&gt;=k;j–) &#123; L-&gt;data[j+1]=L-&gt;data[j]; &#125; L-&gt;data[k]=y; &#125;&#125;int main()&#123; sqlist la; int n,x,y; int a[1000]; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); scanf(“%d%d”,&amp;x,&amp;y); initlist(la); creatlist(la,a,n); insertlist(la,x,y); desplist(la); return 0;&#125; [952] 单链表的插入操作的实现思路题目描述python代码实现数据结构实现链表插入操作。。 传送门 描述 建立长度为n的单链表，在第i个结点之前插入数据元素data。 输入 第一行为自然数n，表示链式线性表的长度；第二行为n个自然数表示链式线性表各元素值；第三行为指定插入的位置i；第四行为待插入数据元素data。 输出 指定插入位置合法时候，输出插入元素后的链式线性表的所有元素，元素之间用一个空格隔开。输入不合法，输出”error!”。 样例输入123451 2 3 4 536 样例输出11 2 6 3 4 5 12345678910111213141516171819202122232425import sysa = []n = int(input())a = list(map(int,raw_input().split()))x = int(input())y = int(input())c = 0if x == 0: a.insert(x,y)elif 0 &lt; x &lt;= len(a): a.insert(x - 1,y)elif x == len(a)+1: a.append(y)else: c = 1if c == 1: sys.stdout.write(“error!”)else: for i in range(len(a)): print a[i], 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL; &#125; void creatlist(linknode &amp;L,int a[],int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); s-&gt;data=a[i]; r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125;void desplist(linknode L)&#123; linknode p=L-&gt;next; while(p!=NULL) &#123; printf(“%d “,p-&gt;data); p=p-&gt;next; &#125;&#125;int listinsert(linknode &amp;L,int i,elemtype e)&#123; linknode p=L,s; int c=0; for(int j=0;j&lt;i-1&amp;&amp;p!=NULL;j++) &#123; p=p-&gt;next; &#125; if(p==NULL) c=1; else &#123; s=(linknode )malloc(sizeof(linknode)); s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125; return c;&#125;int main()&#123; linknode *la; int n,a[1000]; int i,e; int c; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); initlist(la); creatlist(la,a,n); scanf(“%d%d”,&amp;i,&amp;e); c=listinsert(la,i,e); if(c==1) printf(“error!”); else desplist(la); return 0;&#125; [953] 单链表的删除操作的实现思路题目描述python代码实现数据结构实现删除第i个结点之前的结点，即，当前结点的之前的第二个结点指向当前结点 传送门 描述 建立长度为n的单链表，删除第i个结点之前的结点。 输入 第一行为自然数n，表示链式线性表的长度；第二行为n个自然数表示链式线性表各元素值；第三行为指定的删除参数i。 输出 指定删除位置合法时候，输出删除元素后的链式线性表的所有元素，元素之间用一个空格隔开。输入不合法，输出”error!”。 样例输入12351 2 3 4 53 样例输出11 3 4 5 12345678910111213141516import sysa = []b = int(input())a = list(map(int, raw_input().split()))k = int(input())if k&gt;1 and k&lt;=b: a.pop(k-2) for i in range(len(a)): print a[i],else: sys.stdout.write(“error!”) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL;&#125;void creatlist(linknode &amp;L,int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%d”,&amp;s-&gt;data); r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125;void listdelete(linknode &amp;L,int i)&#123; int j=1; linknode p=L,q; while(j&lt;i-1&amp;&amp;p!=NULL) &#123; j++; p=p-&gt;next; &#125; q=p-&gt;next; p-&gt;next=q-&gt;next; free(q);&#125;void desplist(linknode L)&#123; linknode p=L-&gt;next; while(p!=NULL) &#123; printf(“%d “,p-&gt;data); p=p-&gt;next; &#125; //printf(“\n”);&#125;int main()&#123; linknode la; int n,i; scanf(“%d”,&amp;n); initlist(la); creatlist(la,n); scanf(“%d”,&amp;i); if(i&lt;=1||i&gt;n+1) printf(“error!”); else &#123; listdelete(la,i); desplist(la); &#125; return 0; &#125; [954] 单链表的链接思路题目描述python代码实现数据结构实现上个链表的尾指向下个链表的头 传送门 描述 建立长度为n的单链表A和长度为m的单链表B。编程实现将B表链接在A表的尾端，形成一个单链表A。数据类型指定为字符型。 输入 第一行为A表的长度n；第二行为A表中的数据元素;第三行为B表的长度m；第四行为B表中的数据元素。 输出 输出为链接好后的A表中的所有数据元素。 样例输入12344A B C D 61 2 3 4 5 6 样例输出1A B C D 1 2 3 4 5 6 123456789101112131415a = []n1 = int(input())a = list(raw_input().split())b = []n2 = int(input())b = list(raw_input().split())c = a + bfor i in range(len(c)): print c[i], 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef char elem;typedef struct node&#123; elem a; struct node next;&#125;linknode;void initlist (linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL;&#125;void creatlist(linknode &amp;L,int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%c”,&amp;s-&gt;a); getchar(); r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125;void desplist(linknode &amp;L)&#123; linknode p=L-&gt;next; while(p!=NULL) &#123; printf(“%c “,p-&gt;a); p=p-&gt;next; &#125;&#125;void combinelist(linknode &amp;l,linknode &amp;k)&#123; linknode p=l-&gt;next; while(p-&gt;next) &#123; p=p-&gt;next; &#125; p-&gt;next=k-&gt;next;&#125;int main()&#123; int m,n; while(~scanf(“%d”,&amp;m)) &#123; getchar(); linknode r,*s; initlist(r); creatlist(r,m); scanf(“%d”,&amp;n); getchar(); initlist(s); creatlist(s,n); combinelist(r,s); desplist(r); &#125; return 0;&#125; [955] 单链表上查找算法的实现思路题目描述python代码实现数据结构实现遍历，查找 传送门 描述 建立长度为n的单链表A和长度为m的单链表B。编程实现将B表链接在A表的尾端，形成一个单链表A。数据类型指定为字符型。 输入 第一行为链表的长度n；第二行为链表中的数据元素；第三行为要找的结点i。 输出 找到就输出ok，没找到就输出error。 样例输入123101 2 3 4 5 6 7 8 9 105 样例输出1ok 123456789import sysraw_input()if raw_input().find(raw_input()) != -1: sys.stdout.write(“ok”)else: sys.stdout.write(“error”) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef int elem;typedef struct node&#123; elem data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL; &#125; void creatlist(linknode &amp;L,int n) &#123; linknode r,s; r=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%d”,&amp;s-&gt;data); r-&gt;next=s; r=s; &#125; r-&gt;next=NULL; &#125; void findlist(linknode &amp;L,int e) &#123; linknode s=L-&gt;next; while(s!=NULL) &#123; if(s-&gt;data==e) &#123; printf(“ok”); return; &#125; s=s-&gt;next; &#125; if(s==NULL) printf(“error”); return; &#125; int main()&#123; int n,e; while(~scanf(“%d”,&amp;n)) &#123; linknode *la; initlist(la); creatlist(la,n); scanf(“%d”,&amp;e); findlist(la,e); &#125; return 0; &#125;#数组实现#include&lt;stdio.h&gt;int main()&#123; int n,x; int flag = 0; int a[1000]; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;a[i]); &#125; scanf(“%d”,&amp;x); for(int i=0;i&lt;n;i++) &#123; if(x == a[i]) &#123; flag = 1; break; &#125; &#125; if(flag == 1) printf(“ok”); else printf(“error”); return 0; &#125; [956] 约瑟夫问题思路题目描述python代码实现数据结构实现百度：约瑟夫环 传送门 描述 n个人围成一个圈，每个人分别标注为1、2、…、n，要求从1号从1开始报数，报到k的人出圈，接着下一个人又从1开始报数，如此循环，直到只剩最后一个人时，该人即为胜利者。例如当n=10,k=4时，依次出列的人分别为4、8、2、7、3、10，9、1、6、5，则5号位置的人为胜利者。给定n个人，请你编程计算出最后胜利者标号数。（要求用单循环链表完成。） 输入 第一行为人数n;第二行为报数k。 输出 输出最后胜利者的标号数。 样例输入1210 4 样例输出15 1234567891011import sysn = int(raw_input())m = int(raw_input())s = 0for i in range(2,n+1): s = (s + m) % ia = s + 1sys.stdout.write(‘%d’%a) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/#include&lt;stdio.h&gt;int main()&#123; int n,m,i,s=0; scanf(“%d%d”,&amp;n,&amp;m); for(i=2;i&lt;=n;i++) s=(s+m)%i; printf(“%d”,s+1); return 0; &#125; / #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct node&#123; int data; struct node next;&#125;linknode;int main()&#123; linknode L,r,s; L=(linknode )malloc(sizeof(linknode)); r=L; int n,i; int k; scanf(“%d%d”,&amp;n,&amp;k); for(i=1;i&lt;=n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); s-&gt;data=i; r-&gt;next=s; r=s; &#125; r-&gt;next=L-&gt;next; linknode *p; p=L-&gt;next; while(p-&gt;next!=p) &#123; for(i=1;i&lt;k-1;i++) &#123; p=p-&gt;next; &#125; p-&gt;next=p-&gt;next-&gt;next; p=p-&gt;next; &#125; printf(“%d”,p-&gt;data); return 0;&#125; [957] 逆置单链表思路题目描述python代码实现数据结构实现试试倒着输出 传送门 描述 建立长度为n的单链表，然后将其数据元素逆置，即第1个元素变为最后一个元素，第2个元素变为倒数第2个元素，以此类推，最后一个元素变为第1个元素。（处理的数据类型为字符型。必须使用链表完成。） 输入 第一行为链表长度n；第二行为链表中的n个数据元素的值。 输出 逆置后的原始的值。 样例输入1210ABCDEFGHIJ 样例输出1J I H G F E D C B A 1234567891011121314151617try: while True: n=int (input()) a = [] d = 0 for x in raw_input(): a.append(x) d = d+1 for i in range(d-1,-1,-1): print a[i],except EOFError: exit() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef char elem;typedef struct node&#123; elem data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL;&#125;void creatlist(linknode &amp;L,int n)&#123; linknode s; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL; for(int i=0;i&lt;=n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%c”,&amp;s-&gt;data); s-&gt;next=L-&gt;next; L-&gt;next=s; &#125;&#125;void desplist(linknode &amp;L)&#123; linknode p=L-&gt;next; while(p-&gt;next!=NULL) &#123; printf(“%c “,p-&gt;data); p=p-&gt;next; &#125; &#125;int main()&#123; int n; scanf(“%d”,&amp;n); linknode la; initlist(la); creatlist(la,n); desplist(la); return 0;&#125; [960] 双向链表的操作问题思路题目描述python代码实现数据结构实现。。。 传送门 描述 建立一个长度为n的带头结点的双向链表，使得该链表中的数据元素递增有序排列。（必须使用双向链表完成，数据类型为整型。） 输入 第一行：双向表的长度；第二行：链表中的数据元素。 输出 输出双向链表中的数据元素的值。 样例输入12102 4 6 3 5 8 10 21 12 9 样例输出12 3 4 5 6 8 9 10 12 21 1234567891011a = []n = int(input())a = list(map(int, raw_input().split()))a.sort(reverse = False)for i in range(len(a)): print a[i], 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;typedef struct node&#123; int data; struct node prior; struct node next;&#125;linknode;void creatlist(linknode &amp;L,int a[],int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; r-&gt;prior=NULL; for(int i=0;i&lt;n;i++) &#123; r-&gt;data=a[i]; s=(linknode )malloc(sizeof(linknode)); r-&gt;next=s; s-&gt;prior=r; s-&gt;next=NULL; r=s; &#125; r-&gt;next=NULL;&#125;void paixu(linknode root )&#123; linknode p,q; p=root; q=root-&gt;next; while(p!=NULL) &#123; int t; q=root-&gt;next; while(q!=NULL) &#123; if(p-&gt;data&gt;q-&gt;data) &#123; t=p-&gt;data; p-&gt;data=q-&gt;data; q-&gt;data=t; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;“ “&lt;&lt;q-&gt;data&lt;&lt;endl; q=q-&gt;next; &#125; p=p-&gt;next; &#125;&#125;void display(linknode head)&#123; linknode p=head-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl; &#125; void output(linknode root)&#123; linknode p=root; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;“ “; p=p-&gt;next; &#125;&#125;int main()&#123; linknode *root; int n,a[100]; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;a[i]); &#125; creatlist(root,a,n); paixu(root); output(root); return 0;&#125; [961] 进制转换问题思路题目描述python代码实现数据结构实现百度：十进制转二进制 传送门 描述 建立顺序栈或链栈，编写程序实现十进制数到二进制数的转换。 输入 输入只有一行，就是十进制整数。 输出 转换后的二进制数。 样例输入110 样例输出11010 1234567891011121314import sysdef Dec2Bin(dec): result = ‘’ if dec: result = Dec2Bin(dec // 2) return result + str(dec % 2) else: return resultn = int(raw_input())sys.stdout.write(Dec2Bin(n)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define max 100typedef int elemtype;typedef struct&#123; elemtype data[max]; int top;&#125;sqstack;void initstack(sqstack &amp;s)&#123; s=(sqstack )malloc(sizeof(sqstack)); s-&gt;top=-1;&#125;void push(sqstack &amp;s,elemtype e)&#123; s-&gt;top++; s-&gt;data[s-&gt;top]=e;&#125;void pop(sqstack &amp;s,elemtype &amp;e)&#123; e=s-&gt;data[s-&gt;top]; s-&gt;top–;&#125;int empty(sqstack &amp;s)&#123; return (s-&gt;top==-1);&#125;void conversion(int n)&#123; int e; sqstack p=(sqstack *)malloc(sizeof(sqstack)); initstack(p); while(n) &#123; push(p,n%2); n=n/2; &#125; while(!empty(p)) &#123; pop(p,e); printf(“%d”,e); &#125;&#125;int main()&#123; int n; scanf(“%d”,&amp;n); conversion(n); return 0;&#125; [963] 小偷的背包思路题目描述python代码实现数据结构实现背包 传送门 描述 设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…，wn。问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。如果有满足条件的选择，则此背包有解，否则此背包问题无解。 输入 第一行为物品重量S（整数）；第二行为物品数量n，第三行为n件物品的重量的序列。 输出 有解就输出”yes!“，没有解就输出”no!“。 样例输入1232051 3 5 7 9 样例输出1yes! 123456789101112131415161718192021222324import sysdef pack(weight,amonut): if weight == 0: return 1 if weight &lt; 0 or (weight &gt; 0 and amonut &lt; 1): return 0 if pack(weight - get_weight[amonut - 1],amonut - 1 ): return 1 else: return pack(weight,amonut - 1)get_weight = []weight = int(input())amount = int(input())get_weight = list(map(int,raw_input().split()))if pack(weight, amount): sys.stdout.write(“yes!”)else: sys.stdout.write(“no!”) 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int get_weight[100];int pack(int weight,int amonut)&#123; if(weight==0) &#123; return 1; &#125; if(weight&lt;0||(weight&gt;0&amp;&amp;amonut&lt;1)) &#123; return 0; &#125; if(pack(weight-get_weight[amonut-1],amonut-1)) &#123; return 1; &#125; else return pack(weight,amonut-1); &#125;int main()&#123; int weight,amonut; scanf(“%d%d”,&amp;weight,&amp;amonut); for(int i=0;i&lt;amonut;i++) &#123; scanf(“%d”,&amp;get_weight[i]); &#125; if(pack(weight,amonut)) printf(“yes!”); else printf(“no!”); return 0;&#125; [966] 打印杨辉三角形思路题目描述python代码实现数据结构实现打印。 传送门 描述 杨辉三角形具有如下特征： 1、每行数字左右对称，由1开始逐渐变大，然后变小，回到1。 2、第n行的数字个数为n个。 3、第n行数字和为2^(n－1)。 4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。 5、将第2n+1行第1个数，跟第2n+2行第3个数、第2n+3行第5个数……连成一线，这些数的和是第2n个斐波那契数。将第2n行第2个数，跟第2n+1行第4个数、第2n+2行第6个数……这些数之和是第2n-1个斐波那契数。 6、第n行的第1个数为1，第二个数为1×(n-1)，第三个数为1×(n-1)×（n-2）/2，第四个数为1×(n-1)×（n-2）/2×（n-3）/3…依此类推。例如7阶杨辉三角形如下： 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 要求：利用循环队列，编程实现打印杨辉三角形。（n在0-12之间取值） 输入 输入要打印的杨辉三角形的阶n。 输出 打印出n阶杨辉三角形。 样例输入17 样例输出123456711 11 2 11 3 3 11 4 6 4 11 5 10 10 5 11 6 15 20 15 6 1 12345678910111213def disp(i, j): if j == 1 or j == i: return 1 else: return disp(i - 1, j - 1) + disp(i - 1, j)n = int(input())for i in range(1,n + 1): for j in range(1, i+1): print disp(i,j), print “\n”, 12345678910111213141516171819202122#include&lt;stdio.h&gt;int disp(int i,int j)&#123; if((j==1)||(j==i)) return 1; else return (disp(i-1,j-1)+disp(i-1,j));&#125;int main()&#123; int i,j,n; scanf(“%d”,&amp;n); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;i+1;j++) &#123; printf(“%d “,disp(i,j)); &#125; printf(“\n”); &#125; return 0;&#125; [1027] 舞伴问题思路题目描述python代码实现数据结构实现循环 传送门 描述 假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。要求编写程序实现舞伴问题。 输入 输入一共5行，第一行是男生人数m；第二行依次是男生的姓名；第三行是女士的人数n；第四行依次是女士的姓名；第五行是跳舞的轮数。 输出 配对的男士和女士的姓名。 样例输入1234565A B C D E3F G H2 样例输出1B G 12345678910111213import sysn = int(input())a = list(raw_input().split())m = int(input())b = list(raw_input().split())k = int(input())sys.stdout.write(‘%c %c’%(a[(k-1)%n], b[(k-1)%m])) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; char data[100]; int front,rear;&#125;queue;void initqueue(queue &amp;q)&#123; q=(queue )malloc(sizeof(queue)); q-&gt;front=q-&gt;rear=0;&#125;void inqueue(queue &amp;q,int max)&#123; char e; for(int i=0;i&lt;max;i++) &#123; getchar(); scanf(“%c”,&amp;e); q-&gt;data[q-&gt;rear]=e; q-&gt;rear=(q-&gt;rear+1)%max; &#125;&#125;void print(queue &amp;q1,queue &amp;q2,int time,int max1,int max2)&#123; for(int i=0;i&lt;time-1;i++) &#123; q1-&gt;front=(q1-&gt;front+1)%max1; q2-&gt;front=(q2-&gt;front+1)%max2; &#125; printf(“%c %c”,q1-&gt;data[q1-&gt;front],q2-&gt;data[q2-&gt;front]);&#125;int main()&#123; queue la,*lb; int max1,max2,time; initqueue(la); initqueue(lb); scanf(“%d”,&amp;max1); inqueue(la,max1); scanf(“%d”,&amp;max2); inqueue(lb,max2); scanf(“%d”,&amp;time); print(la,lb,time,max1,max2); return 0;&#125; [1037] 集合的并运算的实现思路题目描述python代码实现数据结构实现并 传送门 描述 假设有两个集合 A 和 B 分别用两个线性表 LA 和 LB 表示，即线性表中的数据元素即为集合中的成员。编程实现集合A和集合B的并运算。 输入 第一行为集合A的数据元素个数n 第二行输入n个集合A的数据元素 第三行为集合B的数据元素的个数； 第四行输入m个集合B的数据元素。 输出 第一行为A和B的并集. 样例输入1234580 5 6 3 8 7 9 1071 3 4 7 8 9 5 样例输出10 5 6 3 8 7 9 10 1 4 1234567891011121314151617181920a = []n1 = int(input())a = list(map(int,raw_input().split()))b = []n2 = int(input())b = list(map(int,raw_input().split()))for i in range(len(a)): print a[i],for i in range(len(b)): k = 0 for j in range(len(a)): if b[i] == a[j]: k = 1 if k == 0 : print b[i], 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct &#123; int data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;l)&#123; l=(sqlist )malloc(sizeof(sqlist)); l-&gt;length=0;&#125;void creatlist(sqlist &amp;l,int n)&#123; for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;l-&gt;data[i]); &#125; l-&gt;length=n;&#125;void combinelist(sqlist l,sqlist s)&#123; for(int i=0;i&lt;l-&gt;length;i++) &#123; printf(“%d “,l-&gt;data[i]); &#125; for(int i=0;i&lt;s-&gt;length;i++) &#123; int k=0; for(int j=0;j&lt;l-&gt;length;j++) &#123; if(l-&gt;data[j]==s-&gt;data[i]) &#123; k=1; &#125; &#125; if(k==0) printf(“%d “,s-&gt;data[i]); &#125;&#125;int main()&#123; sqlist la,*lb; int n,m; initlist(la); initlist(lb); scanf(“%d”,&amp;n); creatlist(la,n); scanf(“%d”,&amp;m); creatlist(lb,m); combinelist(la,lb); return 0;&#125; [1038] 顺序表中重复数据的删除思路题目描述python代码实现数据结构实现查重 传送门 描述 将存储在顺序表中的长度为n的线性表中指定的数据全部删除。 输入 第一行为顺序表的长度n； 第二行为顺序表中的数据元素； 第三行为指定要删除的元素值。 输出 如果表不空，输出删除指定值后的线性表；如果删除后表空，则输出-1。 样例输入1234811 22 33 44 44 55 44 6644 样例输出111 22 33 55 66 12345678910111213141516import sysa = []n = int(input())a = list(map(int,raw_input().split()))x = int(input())b = 0for i in range(len(a)): if x != a[i]: print a[i], b = 1if b == 0: sys.stdout.write(“-1”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct&#123; int data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;l)&#123; l=(sqlist )malloc(sizeof(sqlist)); l-&gt;length=0;&#125;void creatlist(sqlist &amp;l,int n)&#123; for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;l-&gt;data[i]); &#125; l-&gt;length=n;&#125;void delelist(sqlist l,int e)&#123; int flag=0; for(int i=0;i&lt;l-&gt;length;i++) &#123; if(l-&gt;data[i]!=e) &#123; printf(“%d “,l-&gt;data[i]); flag=1; &#125; &#125; if(flag==0) printf(“-1”);&#125;int main()&#123; sqlist *la; int n,e; scanf(“%d”,&amp;n); initlist(la); creatlist(la,n); scanf(“%d”,&amp;e); delelist(la,e); return 0;&#125; [1044] 顺序栈基本操作的实现思路题目描述python代码实现数据结构实现入栈，出栈，栈顶 传送门 描述 编程实现顺序栈的初始化、入栈、出栈、取栈顶元素和计算栈中元素个数等基本操作。 输入 第一行为入栈元素的个数； 第二行依次为入栈的元素； 出栈操作的次数n. 输出 输出n次出栈后的栈顶元素值。如果是空栈，输出-1. 样例输入12341 2 3 42 样例输出12 1234567891011121314151617import sysn = int(input())a = list(map(int, raw_input().split()))m = int(input())while m: a.pop() m -= 1if len(a) is not 0: sys.stdout.write(‘%d’%a[len(a)-1])else: sys.stdout.write(“-1”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data[1000]; int top;&#125;sqstack;void initstack(sqstack &amp;s)&#123; s=(sqstack )malloc(sizeof(sqstack)); s-&gt;top=-1;&#125;void push(sqstack &amp;s,int e)&#123; s-&gt;top++; s-&gt;data[s-&gt;top]=e;&#125;bool stackempty(sqstack s)&#123; return s-&gt;top==-1;&#125;bool pop(sqstack &amp;s,int &amp;e)&#123; if(s-&gt;top==-1) return 0; e=s-&gt;data[s-&gt;top]; s-&gt;top–; return true;&#125;int main()&#123; sqstack s; int temp,e; initstack(s); int n,a; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;a); push(s,a); &#125; int flag=0; scanf(“%d”,&amp;temp); for(int i=0;i&lt;=temp;i++) &#123; pop(s,e); &#125; if(temp&gt;=n) printf(“-1”); else if(stackempty) &#123; printf(“%d”,e); &#125; return 0;&#125; [1045] 集合的交运算的实现思路题目描述python代码实现数据结构实现交运算 传送门 描述 假设有两个集合 A 和 B 分别用两个线性表 LA 和 LB 表示，即线性表中的数据元素即为集合中的成员。编程实现集合A和集合B的交运算。 输入 第一行为集合A的数据元素个数n;第二行输入n个集合A的数据元素 ;第三行为集合B的数据元素的个数；第四行输入m个集合B的数据元素 输出 A和B的交集 样例输入123480 5 6 3 8 7 9 1071 3 4 7 8 9 5 样例输出15 3 8 7 9 12345678910111213141516a = []n1 = int(input())a = list(map(int,raw_input().split()))b = []n2 = int(input())b = list(map(int,raw_input().split()))for i in range(len(a)): for j in range(len(b)): if a[i] == b[j]: print a[i], 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct &#123; elemtype data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;l)&#123; l=(sqlist )malloc(sizeof(sqlist)); l-&gt;length=0;&#125;void creatlist(sqlist &amp;l,int n)&#123; for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;l-&gt;data[i]); &#125; l-&gt;length=n;&#125;void holist(sqlist &amp;l,sqlist &amp;s)&#123; for(int i=0;i&lt;s-&gt;length;i++) &#123; for(int j=0;j&lt;l-&gt;length;j++) &#123; if(l-&gt;data[j]==s-&gt;data[i]) printf(“%d “,l-&gt;data[i]); &#125; &#125;&#125;int main()&#123; sqlist la,*lb; int m,n; initlist(la); initlist(lb); scanf(“%d”,&amp;m); creatlist(la,m); scanf(“%d”,&amp;n); creatlist(lb,n); holist(la,lb); return 0;&#125; [1102] 顺序表上数据的划分问题的实现思路题目描述python代码实现数据结构实现比较 传送门 描述 建立一个顺序表L，然后以第一个为分界，将所有小于等于它的元素移到该元素的前面，将所有大于它的元素移到该元素的后面。 输入 顺序表长度n；顺序表中的数据元素。 输出 移动后的数据元素。 样例输入121032 5 22 43 23 56 54 57 11 25 样例输出125 11 23 22 5 32 43 56 54 57 1234567891011121314151617n = int(input())a = list(map(int, raw_input().split()))g = a[0]for i in range(1, len(a)): if a[i] &lt; g: k = a[i] a.pop(i) a.insert(0, k)for k in a: print k, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist )malloc(sizeof(sqlist)); L-&gt;length=0;&#125;void creatlist(sqlist &amp;L,int n)&#123; L=(sqlist )malloc(sizeof(sqlist)); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;L-&gt;data[i]); &#125; L-&gt;length=n;&#125;void movlist(sqlist &amp;L)&#123; int p=L-&gt;data[0]; for(int i=L-&gt;length-1;i&gt;=0;i–) &#123; if(L-&gt;data[i]&lt;=p) &#123; printf(“%d “,L-&gt;data[i]); &#125; else continue; &#125; for(int i=0;i&lt;L-&gt;length;i++) &#123; if(L-&gt;data[i]&gt;p) &#123; printf(“%d “,L-&gt;data[i]); &#125; else continue; &#125;&#125;int main()&#123; sqlist la; int n; initlist(la); scanf(“%d”,&amp;n); creatlist(la,n); movlist(la); return 0;&#125; [1103] 删除顺序表中指定区间的数据思路题目描述python代码实现数据结构实现比较、删除 传送门 描述 建立顺序表L，将指定区间的数据从顺序表中删除。假设指定区间是合法数据，无序做合法性判断。测试数据为整型。 输入 第一行是表长n；第二行是表中数据元素。 输出 删除以后的顺序表中的数据元素。 样例输入1231022 32 11 23 43 59 17 65 45 5710 20 样例输出122 32 23 43 59 65 45 57 12345678910111213a = []n = int(input())a = list(map(int,raw_input().split()))x = list(map(int,raw_input().split()))for i in range(len(a)): if a[i] &lt; x[0] or a[i] &gt; x[1]: print a[i], 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist )malloc(sizeof(sqlist)); L-&gt;length=0;&#125;void creatlist(sqlist &amp;L,int n)&#123; L=(sqlist )malloc(sizeof(sqlist)); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;L-&gt;data[i]); &#125; L-&gt;length=n;&#125;void movlist(sqlist &amp;L,int a,int b)&#123; int p=L-&gt;data[0]; for(int i=0;i&lt;L-&gt;length;i++) &#123; if(L-&gt;data[i]&lt;a||L-&gt;data[i]&gt;b) printf(“%d “,L-&gt;data[i]); &#125;&#125;int main()&#123; sqlist la; int n; int a,b; initlist(la); scanf(“%d”,&amp;n); creatlist(la,n); scanf(“%d%d”,&amp;a,&amp;b); movlist(la,a,b); return 0;&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>题解~</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习（一）：KNN算法的实现]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AKNN%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AKNN%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[##描述百度百科 ##算法实现原理： 1.计算已知类别数据集中的点与当前点之间的距离; 2.按照距离递增次序排序； 3.选取与当前点距离最小的k个点； 4.确定前k个点所在类别的出现频率； 5.返回前k个点所出现频率最高的类别作为当前点的预测分类。 ##算法实现： ###数据集的建立及python代码的实现：123456789import numpy as npfrom numpy import *import operator#训练集def creatDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = [&apos;A&apos;,&apos;A&apos;,&apos;B&apos;,&apos;B&apos;] return group, labels ####运行结果： 如下图： ###KNN算法的实现：12345678910111213141516171819202122232425262728293031#KNN分类# inX 用于分类的数据（即测试集）# dataSet 用于训练的数据（即测试集）# labels 分类的标签# k KNN算法中 K 的值def classify(inX,dataSet,labels,k): #计算距离 dataSetSize = dataSet.shape[0] #返回dataSet的行数 diffMat = np.tile(inX, (dataSetSize,1)) - dataSet #inX 在（行向量方向上重复，列向量方向上重复）次数 sqDiffMat = diffMat**2 #二维特征相减后平方 sqDistances = sqDiffMat.sum(axis=1) #相减平方再相加 distances = sqDistances**0.5 #再开方 #排序（从小到大） sortedDistIndices = distances.argsort() #排序并返回下标 classCount = &#123;&#125; #定义一个记录类别次数的字典 for i in range(k): voteIlabel = labels[sortedDistIndices[i]] #取出前K个元素的类别 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #计算类别的次数# key=operator.itemgetter(1)根据字典的值进行排序# key=operator.itemgetter(0)根据字典的键进行排序# reverse降序排序字典 sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True) # 降序排序 return sortedClassCount[0][0] ####测试结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Counterfeit Dollar(枚举)]]></title>
    <url>%2F2018%2F07%2F07%2F%E7%AE%97%E6%B3%95%E5%81%9A%E9%A2%98%2FCounterfeit-Dollar-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[描述传送门 Sally Jones has a dozen Voyageur silver dollars. However, only eleven of the coins are true silver dollars; one coin is counterfeit even though its color and size make it indistinguishable from the real silver dollars. The counterfeit coin has a different weight from the other coins but Sally does not know if it is heavier or lighter than the real coins.Happily, Sally has a friend who loans her a very accurate balance scale. The friend will permit Sally three weighings to find the counterfeit coin. For instance, if Sally weighs two coins against each other and the scales balance then she knows these two coins are true. Now if Sally weighsone of the true coins against a third coin and the scales do not balance then Sally knows the third coin is counterfeit and she can tell whether it is light or heavy depending on whether the balance on which it is placed goes up or down, respectively.By choosing her weighings carefully, Sally is able to ensure that she will find the counterfeit coin with exactly three weighings. input The first line of input is an integer n (n &gt; 0) specifying the number of cases to follow. Each case consists of three lines of input, one for each weighing. Sally has identified each of the coins with the letters A–L. Information on a weighing will be given by two strings of letters and then one of the words “up”, “down”, or “even”. The first string of letters will represent the coins on the left balance; the second string, the coins on the right balance. (Sally will always place the same number of coins on the right balance as on the left balance.) The word in the third position will tell whether the right side of the balance goes up, down, or remains even. output For each case, the output will identify the counterfeit coin by its letter and tell whether it is heavy or light. The solution will always be uniquely determined. 样例12345678910input:1 ABCD EFGH even ABCI EFJK up ABIJ EFGH even output:K is the counterfeit coin and it is light. 题意理解+思路题意理解 题意说一共有12个硬币，其中有一个是假币，不知道是重还是轻，一共可以称量3次来寻找假币。输入第一行是n（n&gt;0），指需要测试的案例数。每个案例由3行输入，用A-L来表示硬币。第一串字母代表天平左边，第二串代表天平右边，第三串字母由 even up down 来分别表示保持平衡、天平右侧上升、天平右侧下降。要求找出假币所代表的的字母并告知是重还是轻。 思路 开12个数组代表A-L，并赋初值为0，若天平平衡，则将左右的所有字母对应的数组都赋值为一个固定的数，若不平衡，则首先除去固定数的数组（数字固定，表示是真币）然后将重的一侧加一，轻的一侧减一。最后遍历数组寻找出绝对值最大的数就是假币，因为这个数字是被怀疑次数最多的。如果除去绝对值为正，则为重，否则为轻。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt; int main()&#123; int n,k,i,t,len,max; char s1[13],s2[13],temp[10]; int a[12]; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; memset(a,0,sizeof(a)); for(t=0;t&lt;3;t++) &#123; scanf(&quot;%s%s%s&quot;,s1,s2,temp); len=strlen(s1); //两边个数肯定相等，所以两边长度也一样,不能只看样例便觉得一定是4而忽略这一步，否则会 WA if(strcmp(temp,&quot;even&quot;)==0) &#123; for(i=0;i&lt;len;++i) &#123; a[s1[i]-&apos;A&apos;]=10; //说明两边都为真，将标记数组置为10（10为自己设置的固定的数，但不能过小否则会错。） a[s2[i]-&apos;A&apos;]=10; &#125; &#125; else if(strcmp(temp,&quot;up&quot;)==0)//说明左边重 &#123; for(i=0;i&lt;len;++i) &#123; if(a[s1[i]-&apos;A&apos;]!=10) ++a[s1[i]-&apos;A&apos;]; //左边加一 if(a[s2[i]-&apos;A&apos;]!=10) --a[s2[i]-&apos;A&apos;]; //右边减一 &#125; &#125; else &#123; for(i=0;i&lt;len;++i) //说明右边重 &#123; if(a[s1[i]-&apos;A&apos;]!=10) --a[s1[i]-&apos;A&apos;]; //左边减一 if(a[s2[i]-&apos;A&apos;]!=10) ++a[s2[i]-&apos;A&apos;]; //右边加一 &#125; &#125; &#125; max=0; k=0; for(i=0;i&lt;12;++i) &#123; if(a[i]==10) continue; if(max&lt;=abs(a[i])) &#123; max=abs(a[i]); k=i; &#125; &#125; if(a[k]&gt;0) //去绝对值后的符号决定轻重。 printf(&quot;%c is the counterfeit coin and it is heavy.\n&quot;,&apos;A&apos;+k); else printf(&quot;%c is the counterfeit coin and it is light.\n&quot;,&apos;A&apos;+k); &#125; return 0; &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在我搭建博客中所遇到的坑]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E5%9C%A8%E6%88%91%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[遇到的第一个坑hexo不显示 在安装hexo的过程中输入 hexo -v 查看hexo安装版本的时候，没有显示hexo的版本。 安装完毕后，理应显示的图为： 然而我的显示图为： 解决办法： 原理：因为需要git bash到你所创建的子文件中，而不是上一层文件中，在上一层文件中不会显示你所安装过的hexo的版本。 遇到的第二个坑背景虚化 在我搭建博客过程中，发现背景要么极暗要么极白，很难调节，加上什么背景图片都很难看清字体。起初我想要更改字体的颜色来弥补，后来发现情况不止如此，问了大佬以后才知道可以去更改一下背景，百度半天虚化背景发现这个背景，没什么进展，问了一个前端大佬，才修改完毕，具体如下:博客根目录 themes\next\source\css_custom这个文件下的custom.styl文件中修改如下：。 嗯~其他坑还在踩，欢迎投稿。。]]></content>
      <categories>
        <category>-解决问题</category>
      </categories>
      <tags>
        <tag>-问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Happy Birthday]]></title>
    <url>%2F2018%2F06%2F27%2F%E5%85%B6%E4%BB%96%2FHappy-Birthday%2F</url>
    <content type="text"><![CDATA[记陪你的第一次生日 2017年6月。 回想起高三那年结束前，你我是同桌，你跟我说快过生日了，但却是高考以后。我就想提前送你一些礼物，无他，只因为你是我同桌。 2017年7月。 后来发生了一些很奇妙的事，渐渐的越来越熟，也就是越来越熟。那年六月，一起高考，那年七月，各奔东西。 2017年8月。 一些事就是缘分问题，也确实是很难的。抉择问题。反正是一起来四川了。挺好的。这个月记得的好像是开学。嗯，对，就是开学。 2017年9月。 这个月印象还是蛮不错的，去了一次成都，第一次去呐，还算可以，问了路程，问了方向，问了倒转车，说走就走了。。 2017年10月。 十月一开学，放假7天，没在学校，去成都浪了。见了三年不见的好友，一起大概的走了成都。反正哪里挤去了哪里，反正缘分这东西，说不清楚。 2017年11月。 这个月没什么太大的波浪，仍然保持着一个月或者两周去看一次的习惯。过的波澜不惊。除了复习备考，好像还有美食节？ 2017年12月。 这个月还凑合，月初啊，月末啊啥的你就过来了，只是来的好像不是时候，完美错过了东八舞池和元旦晚会呐，真是有点遗憾。 2018年1月。 主要在准备考试和考完试的颓废中生活。还行吧，就这样，不过还发现了美食，等着带你来吃。17号回去，一起坐高铁。真是不错。 2018年2月。 这个月就是在家嘛，打游戏多了，你还是挺生气的。14号那天，之前，做了个小视频，送给你了，也就是个小视频呐。凑合。。地址的话，在空间吧。 2018年3月。 开学的日子，去接你，结果你手机被偷了，虽然事情解决了，可是还是心有余悸呐。以后还是要万分小心。不过月底你还是过来陪我耍了两天。开森。 2018年4月。 清明节的时候过去了，我还真的错不过每次的放假呐。一有时间就还是会去，或许就是单纯想去吧。这个月好像实现了半天来回成都？？ 2018年5月。 劳动节的时候去了，也很快就回来了，前一两天，还在学校转悠，第三天还是去了。去了之前没去的地方，还好天气不错。 2018年6月。 因为端午节要考试呐，这个月还是复习备考的一个月，儿童节还是忍住了没去，因为第二天考试。。也在这个月吧，迎来了你的生日呐，还是选择去吧，无他，因为你是我女朋友。 2018年。。。 故事还在继续，那句话咋说来着，我有故事，你有酒吗？]]></content>
      <categories>
        <category>-杂记</category>
      </categories>
      <tags>
        <tag>-生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%85%B6%E4%BB%96%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
