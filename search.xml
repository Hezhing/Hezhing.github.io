<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web安全学习之文件上传漏洞]]></title>
    <url>%2F2019%2F08%2F08%2FWeb%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件上传漏洞文件上传漏洞1.用户上传一个可执行的脚本文件，获得了执行服务器端命令的能力，常见于File-Based的Web应用，PHP，ASP，JSP。 getshell最为常用、直接的方式 “文件上传”本身是一个正常的业务需求，问题在于如何安全上传。 漏洞触发条件 上传的文件被Web容器解释执行。 用户能够从Web网页访问到被上传的文件（直接或者间接） 3.用户上传的文件通常不能被网站程序压缩、修改内容。 本文描述了常见的文件上传校验及绕过检验的各种姿势和对此漏洞提出的防护建议。 注：本文篇幅较长，建议多次食用。转载请保留原文链接及作者。 文件上传校验及绕过姿势1. 客户端JavaScript校验（一般校验后缀名）一般是在网页上写一段JavaScript脚本，检验上传文件的后缀名，有白名单形式也有黑名单形式。 判断方式:在浏览器加载文件，但未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。 绕过方式:抓包改包轻松绕过。或者直接修改前端、或者前端直接用js强制提交。例如：可以利用burp抓包改包，先上传一个gif类型的木马，然后通过burp将其改为asp/php/jsp后缀名即可 2. 服务端校验：2.1 文件头content-type字段校验（image/gif）检验MIME类型，通用语法：type/subtype，常见的例如：text/plain、text/html、image/jpeg、image/png、audio/mpeg、audio/ogg、audio/、video/mp4、application/、application/json、application/javascript、application/ecmascript、application/octet-stream… 具体可以参考 ： 重要的MIME类型 判断方式:代码对上传文件的文件类型进行了判断，如果不是图片类型，返回错误。 绕过方式:可以通过抓包，将content-type字段改为image/gif 2.2 文件内容头校验（GIF89a）可以通过自己写正则匹配，判断文件头内容是否符合要求，这里举几个常见的文件头对应关系： （1） .JPEG;.JPE;.JPG，”JPGGraphic File”​（2） .gif，”GIF 89A”​（3） .zip，”Zip Compressed”​（4） .doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile” 判断方式:检查文件头，从而进行检验。如检查”&lt;?php”头。代码如下： 1234$content=file_get_contents($_FILES["file"]["tmp_name"]);if(stripos($content,needle:"&lt;?php")!=false)&#123; die("you are a hacker! refuse to upload!");&#125; 绕过方式： 将以下内容保存为tset.phtml中进行上传： 123&lt;script language=&quot;php&quot;&gt; phpinfo();&lt;/script&gt; 2.使用php输出表达式： 1&lt;?=system($_REQUEST['cmd'])?&gt; 3.在木马内容基础上再加了一些文件信息，有点像下面的结构 1GIF89a&lt;?php phpinfo(); ?&gt; 2.3 后缀名黑名单校验判断方式:一般有个专门的 blacklist 文件，里面会包含常见的危险脚本文件。如： 1234$name = $_FILES["myfile"]["name"];$ext_name = substr($name,-4);if($name1==".php") die('php!!'); 绕过方法: （1）找黑名单扩展名的漏网之鱼 - 比如 asa 和 cer 之类（2）可能存在大小写绕过漏洞 - 比如 aSp 和 pHp 之类 能被解析的文件扩展名列表：php3 php5 phtml PHP pHp phtm jsp jspx jspf asp asa cer aspx exe exee等 2.4 后缀名白名单校验2.4.1 配合文件包含漏洞：前提:校验规则只校验当文件后缀名为asp/php/jsp的文件内容是否为木马。 123$file_array=getimagesize($_FILES["file"]["tmp_name"]);if($file_array[0]&lt;=0||$file_array[1]&lt;=0) die("this is not a real image! abort uploading!") 对于这个，可以上传一张真正的图片，再把上传的文件抓包，后缀改为php，再将php代码写在图片的最后，即可绕过 绕过方式：（这里拿php为例，此漏洞主要存在于PHP中）​（1）先上传一个内容为木马的txt后缀文件，因为后缀名的关系没有检验内容；​（2）然后再上传一个.php的文件，内容为: 1&lt;?php include(“上传的txt文件路径”);?&gt; 此时，这个php文件就会去引用txt文件的内容，从而绕过校验。 2.4.2 截断绕过漏洞：0x00截断原理:最基于一个组合逻辑漏洞造成的，通常存在于构造上传文件路径的时候。文件名后缀就一个%00字节，可以阶段某些函数对文件名的判断。 在许多语言函数中，处理字符串的函数中0x00被认为是终止符。代码如下： 12345678910$name = $_FILES['myfile']['name'];$ext_name = substr($name,-4);if(($name1==".gif") and ($name1!=".jpg")) die('error');$file_true_name=md5(rand(1,1000)).$_FILES['myfile']['name'];if(move_upload_file($uploaded_file,$file_true_name))&#123; echo $_FILES['myfile']['name']."上传成功";&#125;else&#123; echo "上传失败";&#125; 绕过方式:网站上传函数处理xxx.php%00.jpg时，首先后缀名是合法的jpg格式，可以上传，在保存文件时，遇到%00字符丢弃后面的jpg，文件后缀最终保存的后缀名为xxx.php。 构造方式有：test.php(0x00).jpg test.php%00.jpg 2.4.3 利用NTFS ADS特性绕过如果上传的文件名字为：test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析。假设我们需要上传的文件内容为： 1&lt;?php phpinfo();?&gt; 下面是上传是会出现的现象： 上传的文件名 服务器表面现象 生成的文件内容 绕过方式：上传test.php:a.jpg的时候其实是在服务器上正常生成了一个数据流文件，可以通过notepad test.php:a.jpg查看内容，而test.php为空也是正常的。 根据第二个现象，我们可以bypass一些黑名单验证。 2.4.4 服务器解析漏洞2.4.4.1 IIS5.x-6.x 解析漏洞使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件。 绕过方式： 1.目录解析：www.xxx.com/xx.asp/xx.jpg(xx.asp)。服务器默认会把.asp，.asa目录下的文件都解析成asp文件。 2.文件解析： www.xxx.com/xx.asp;.jpg 服务器默认不解析”;“之后的内容，因此xxx.asp;.jpg便被解析成asp文件了，但上传的是jpg文件（xx.asp;.jpg为上传文件）。 IIS6.0 默认的可执行文件除了asp还包含这三种 :/test.asa /test.cer /test.cdx 2.4.4.2 apache 解析漏洞Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。 绕过方式:构造如下url：www.xxxx.xxx.com/test.php.php123 2.4.4.3 nginx 解析漏洞（Nginx&lt;8.03）原理:Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑： PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了 绕过方式： www.xxxx.com/UploadFiles/image/1.jpg/1.phpwww.xxxx.com/UploadFiles/image/1.jpg%00.phpwww.xxxx.com/UploadFiles/image/1.jpg/%20\0.php另一种方式：上传一个名字为test.jpg，以下内容的文件。 1&lt;?PHP fputs(fopen('shell.php','w'),'&lt;?php eval($_POST[cmd])?&gt;');?&gt; 然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。 2.4.4.4 IIS的PUT上传PUT是在WebDav中定义的一个方法，允许用户上传文件到指定目录。在血多WebServer中都默认禁用了此方法，或者对上传做了严格的限制，但在IIS中，如果目录支持写权限，同时开启了WebDav，就会支持PUT，再结合MOVE方法，课getshell绕过方法：1.通过Options探测服务器信息。 2.上传文件 3.通过MOVE改名。 2.4.5 CMS 编辑器漏洞（1）CMS漏洞：比如说JCMS等存在的漏洞，可以针对不同CMS存在的上传漏洞进行绕过。 （2）编辑器漏洞：比如FCK，ewebeditor等，可以针对编辑器的漏洞进行绕过。这两方面的漏洞以后单独成文汇总，这里点到为止。 2.5 自定义正则校验3. WAF绕过3.1 垃圾数据有些主机WAF软件为了不影响Web服务器性能，会对校验的用户数据设置大小上限，比如1M，此种情况可以构造大文件，前面传1M的内容为垃圾内容，后面传木马内容便可以绕过。也可以将垃圾数据放到数据包最开头，这样便可以绕过对文件名的校验。 3.2 filename针对最早期版本的安全狗，可以多加一个filename 3.3 POST/GET有些WAF规则是：如果数据包为POST类型，则校验数据包内容，此种情况可以传一个POST型的数据包，抓包将POST改为GET。 3.4 以上方式针对WAF，以上介绍的服务器解析漏洞，文件包含漏洞等都可以尝试绕过。 3.5 利用waf本身的缺陷。 删除实体里面的Conten-Type字段。一种是删除Content正行，一种是删除C后面的字符，删除掉ontent-Type：image/jpeg只留下C，将.php加到C后面即可。但是要注意，双引号跟C.php，如下： 123正常包：Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.png&quot;Content-Type: image/png构造包：Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.pngC.php&quot; 删除Content-Disposition: form-data字段里面的空格。如下这个空格。 增加一个空格导致安全狗被绕过案列： 12改前：Content-Type: multipart/form-data; boundary=—————————4714631421141173021852555099改后：boundary= —————————47146314211411730218525550 尝试在boundary后面加个空格或者其他可被正常处理的字符： 尝试在boundary后面加个空格或者其他可被正常处理的字符： 修改Content-Disposition字段值的大小写。如：把name改成nAme Boundary边界不一致。每次文件上传时的Boundary边界都是一致的：但如果容器在处理的过程中并没有严格要求一致的话可能会导致一个问题，两段Boundary不一致使得waf认为这段数据是无意义的，可是容器并没有那么严谨： 文件名处回车。 多个Content-Disposition。在IIS的环境下，上传文件时如果存在多个Content-Disposition的话，IIS会取第一个Content-Disposition中的值作为接收参数，而如果waf只是取最后一个的话便会被绕过， 4. 其他情况绕过4.1 文件重命名绕过如果web程序会将filename除了扩展名的那段重命名的话，那么还可以构造更多的点、符号等等。 4.2 特殊的长文件名绕过如：文件名使用非字母数字，比如中文等最大程度的拉长，不行的话再结合一下其他的特性进行测试：shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg 4.3 反删除将file1改成了file4，这样就不会把这个文件删除了。（JCMS漏洞） 5.文件校验的几点建议 文件扩展名服务端白名单校验。 文件内容服务端校验。 上传文件重命名。 隐藏上传文件路径。 参考文章： ​ nmake’s Blog ​ i春秋转载]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello2019]]></title>
    <url>%2F2019%2F08%2F06%2Fhello2019%2F</url>
    <content type="text"><![CDATA[本网站自2018年6月23日运行以来，共计推送11篇文章，由于种种原因（主要是我太懒），一直未曾更新。但经过深刻反思，决定重新拾起博客，开始更新。欢迎各位大佬指正。]]></content>
      <tags>
        <tag>-life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python安装mysqlclinent报错及解决]]></title>
    <url>%2F2018%2F10%2F21%2FPython%E5%AE%89%E8%A3%85mysqlclinent%E6%8A%A5%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[遇见的问题 学习Django的时候需要使用数据库，在安装的过程中出现报错。 问题 报错：_mysql.c(42) : fatal error C1083: Cannot open include file: ‘config-win.h’: No such file or directory 问题一解决： 参考我的上一篇文章，Windows下安装Scrapy框架遇到的问题不过现在不是下载Twisted，而是下载mysqlclient，下载版本依电脑配置而定。安装如下：]]></content>
      <categories>
        <category>-解决问题</category>
      </categories>
      <tags>
        <tag>-python包安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python Django框架的文档查找系统]]></title>
    <url>%2F2018%2F10%2F16%2FDjango%2F</url>
    <content type="text"><![CDATA[Django项目的创建和运行。cmd运行命令 创建项目 （1）创建项目命令：django-admin startproject + 项目名称创建的文件的目录：目录介绍：（1） init .py :说明test1是一个Python包（2）setting.py :项目的配置文件（3）urls.py :进行url路由的配置（4）wsgi.py :web服务器和django交互的入口（5） manage.py :项目管理文件、 创建应用 （2）创建应用命令：python manage.py startapp +应用名称 注：需要在项目目录下创建，否则不生效。应用创建目录：目录介绍：（1） init .py :说明目录是一个Python模块（2）models.py :写和数据库相关内容（3）views.py :视图函数（4）test.py :写测试代码的文件（5）admin.py :网站后台管理相关文件 链接应用 打开setting.py文件，在INSTALLAPP下添加应用名称。 运行项目 直接在cmd中输入命令：python manage.py runserver 然后访问：http://localhost:8000/ #]]></content>
      <categories>
        <category>实验室项目开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 iso文件下载及虚拟机安装]]></title>
    <url>%2F2018%2F10%2F15%2FUbuntu16-04-iso%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8F%8A%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[#下载下载地址 点击如下下载32位或者64位iso文件，这里我下载的是64位桌面版的然后打开VMware Workstation进行安装操作，具体参照下面图片 首先新建然后典型，下一步。选择下载的iso文件.后面按部就班操作就行。]]></content>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[歌单推荐]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%AD%8C%E5%8D%95%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[[20181003]歌名歌手推荐理由优美歌词摘抄生命中的时光 链接 齐一 齐一不便多说，第一次听到他的声音，是那首《这个年纪》，苍翠有力，活泼俏皮，当时没少单曲循环。今日首推这首歌，作词作曲皆为上品，“想要把自己活成一场梦，一首歌一部电影。”已经折服了我。少不了励志词语，”每天醒来的时候照照镜子，用一个微笑补偿自己”。让人不禁感叹，生命中那些难熬的时光，终将会在某一天找到所有孤独的意义。 在只有凌晨才不会太拥挤的城市我披星戴月独自穿行 想要把自己活成一场梦一首歌一部电影就算会半梦半醒就算压（押）不上韵却还是期待所有故事结局 我会在每天醒来的时候照照镜子用一个微笑补偿自己生活太不容易却仍不甘心问问自己是否拼尽全力 我也佩服我的勇气也心疼所有孤独的意义 [20181004]歌名歌手推荐理由优美歌词摘抄这个年纪 链接 齐一 这是我听的齐一的第一首歌，当时我是高三，正值年少，资历尚且，无法听出歌中的无助和难以为继。齐一当时年过三十，缺乏了我这个年纪的冲动，多了一丝成熟稳重，从他口中唱出的词多了一丝岁月的韵味，可能就是那一句话，该来的总会来该走的也无法挽留折服了我。如今再看，没了一些东西，又有了一些东西。或许当我年过三十再回首，可能会感叹，这就是生活吧。 当我习惯把实话都变成了童话那我的单纯呢 那我的单纯呢这个年纪我已不再将就有些事情无法强求该来的总会来该走的也无法挽留 [20181005]歌名歌手推荐理由优美歌词摘抄只只 链接 孟凡明 以前从未听过他的歌。遇到这首歌纯属意外。初感是一首写给另一半的歌曲，用词相比之前所听又没许多。作曲相对平缓很多，不像其他歌曲时而沉浮时而激烈，“十月过后的天空，醉酒般晕红”，初听时并不觉有多好听，但越听越觉有味。可能这就是平淡的喜欢一个人的感觉。把两个相恋的人的日常写的平淡无奇，却唱的深沉浓烈。 在山野间追风，去看遍世界黄昏与黎明 任时间过往匆匆，轻易就远去无声在人潮之中，想要拥抱你，哪怕片刻永恒我已经偷偷决定，把爱你的事澄清在百念之中，你依然是我，未寻得的旧梦 [20181009]歌名歌手推荐理由优美歌词摘抄可能否 链接 木小雅 不知怎说这首歌，经历过的自然懂的，不撞南墙不回头，不见黄河不死心。人生可能就需要这样的一股子劲，逼着自己，向前冲，管他对与错，管他是与非，管他谁是谁，可能多年之后，南墙撞到了，再不会出现，黄河干了，再不会出现，绝望不见了，成了美好的回忆。但这一起，均是可能否。 可能我撞了南墙才会回头吧可能我见了黄河才会死心吧可能我偏要一条路走到黑吧可能我还没遇见，那个他吧 春天的风 能否吹来夏天的雨秋天的月 能否照亮冬天的雪夜空的星 能否落向晨曦的海山间的泉 能否遇上南飞的雁断掉的弦 能否扯破自缚的茧熄灭的火 能否烧光残留的念梦中的云 能否化作熟悉的脸前世的劫 能否换来今生的缘 能否早一点 看透命运的伏线能否慢一点 挥霍有限的时间能否早一点 相信年少的誓言能否慢一点 感受岁月的缱绻 [20181017]歌名歌手推荐理由优美歌词摘抄倾尽天下 链接 河图 急速的开头可能只是衬托。而后的歌调婉转，歌词非要细听方才懂得。初不觉歌有如何，遂查背景，了解背景后，再回首听这首歌，格调完全不同。歌词讲述了周朝开国皇帝白炎、前朝敬帝与前朝最后一位贵妃朱砂的爱恨情仇。亦是追求爱情的典例。 七重纱衣 血溅了白纱兵临城下六军不发谁知再见已是 生死无话 明月照亮天涯最后谁又 得到了蒹葭江山嘶鸣战马怀抱中那 寂静的喧哗 回到那一刹那岁月无声也让人害怕枯藤长出枝桠原来时光已翩然轻擦 [20181020]歌名歌手推荐理由优美歌词摘抄年少有为 链接 李荣浩 李荣浩留给我的不止迷人的眼睛，还有那真切的痛感。听歌至今，也仅知他歌声的言语，带着几分自嘲，带着几分玩笑，带着几分不愿向生活妥协的倔强。“假如我年少有为不自卑，懂得什么是珍贵”，“加入我年少有为知进退，才不会让你替我受罪”，既是爱情，又是生活。能把生活写成歌词的人，又有几个。 假如我年少有为不自卑懂得什么是珍贵那些美梦没给你 我一生有愧假如我年少有为知进退才不会让你替我受罪婚礼上多喝几杯和你现在那位]]></content>
      <categories>
        <category>歌单</category>
      </categories>
      <tags>
        <tag>歌单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Scrapy框架遇到的问题]]></title>
    <url>%2F2018%2F08%2F28%2FWindows%E4%B8%8B%E5%AE%89%E8%A3%85Scrapy%E6%A1%86%E6%9E%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[##遇见如下错误： error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools” ##解决办法如下： 一般按照提示是需要安装一个C++14.0的一个库，但是进入网址后，此库总的有4G这么大，下载安装肯定不现实，好在在这里有文件，可以先行下载。不过是个国外网站，需要科学上网，不过现在貌似进的挺快的。下载的文件为这个： 然后执行操作为：然后再次执行操作：pip install Scrapy]]></content>
      <categories>
        <category>-解决问题</category>
      </categories>
      <tags>
        <tag>-问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swust oj数据结构前40题中的20个python实现]]></title>
    <url>%2F2018%2F08%2F02%2Fswust-oj%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%8D40%E9%A2%98%E4%B8%AD%E7%9A%8420%E4%B8%AApython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[#注意：学校oj python所用的是python2，用python3交会报CE 不要问我怎么知道的，当你有满屏CE的时候，你会知道的。 [941] 有序顺序表的合并操作的实现思路题目描述python代码实现数据结构实现比较a列表和b列表的大小，然后按顺序放到 c列表里 传送门 描述 已知两非递减的顺序线性表，要求合并成一个新的非递减顺序线性表。(测试数据为整型) 输入 输入包含四行，第一行为自然数n，表示第一个非递减顺序线性表的长度;第二行为n个自然数构成的非递减顺序线性表;第三行为自然数m，表示第二个非递减顺序线性表的长度;第四行为m个自然数构成的非递减顺序线性表 输出 用一行输出合并后的非递减顺序线性表，各数之间用一个空格隔开。 样例输入123421 332 3 6 样例输出11 2 3 3 6 1234567891011121314151617181920212223242526272829303132a = []n1 = int(input())a = list(map(int,raw_input().split()))b = []n2 = int(input())b = list(map(int,raw_input().split()))len_a = len(a)len_b = len(b)la, lb = 0, 0c = []while la &lt; len_a and lb &lt; len_b: if a[la] &lt; b[lb]: c.append(a[la]) la += 1 else: c.append(b[lb]) lb += 1while la &lt; len_a: c.append(a[la]) la += 1while lb &lt; len_b: c.append(b[lb]) lb += 1for i in range(la + lb): print c[i], 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct&#123; elemtype data[500]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist )malloc(sizeof(sqlist)); L-&gt;length=0; &#125; void creatlist(sqlist &amp;L,elemtype a[],int n)&#123; int i=0; for(i=0;i&lt;n;i++) &#123; L-&gt;data[i]=a[i]; &#125; L-&gt;length=n;&#125;void desplist(sqlist L)&#123; int i; printf(“%d”,L-&gt;data[0]); for(i=1;i&lt; L-&gt;length;i++) &#123; printf(“ %d”,L-&gt;data[i]); &#125; printf(“\n”);&#125;void Combine(sqlist &amp;la,sqlist &amp;lb,sqlist &amp;lc)&#123; int i=0,j=0,k=0; while(i&lt;la-&gt;length&amp;&amp;j&lt;lb-&gt;length) &#123; if(la-&gt;data[i]&lt;=lb-&gt;data[j]) &#123; lc-&gt;data[k]=la-&gt;data[i]; k++;i++; &#125; else &#123; lc-&gt;data[k]=lb-&gt;data[j]; k++;j++; &#125; &#125; while(i&lt;la-&gt;length) &#123; lc-&gt;data[k]=la-&gt;data[i]; k++;i++; &#125; while(j&lt;lb-&gt;length) &#123; lc-&gt;data[k]=lb-&gt;data[j]; k++;j++; &#125; lc-&gt;length=k;&#125;int main()&#123; sqlist la; sqlist lb; sqlist lc; int a[1000],b[1000]; int n,m; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); scanf(“%d”,&amp;m); for(int j=0;j&lt;m;j++) scanf(“%d”,&amp;b[j]); initlist(la); initlist(lb); initlist(lc); creatlist(la,a,n); creatlist(lb,b,m); Combine(la,lb,lc); desplist(lc); return 0;&#125; [942] 逆置顺序表思路题目描述python代码实现数据结构实现… 传送门 描述 建立长度为n的顺序表，然后将表中的数据元素逆置，即若表中原来的数据元素序列为（a0，a1，a2，…，an），则逆置后的数据元素序列为（an，an-1，an-2，…，a1，a0）。（数据类型为字符型） 输入 第一行为顺序表的长度n；第二行为顺序表中的数据元素. 输出 输出为逆置后的顺序表. 样例输入127ABCDEFG 样例输出1G F E D C B A 123456789101112try: while True: #循环 n=int (input()) a = [] d = 0 for x in raw_input(): a.append(x) d = d+1 for i in range(d-1,-1,-1): print a[i],except EOFError: exit() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char ElemType;typedef struct&#123; ElemType data[5000]; int length; &#125;SqList;void InitList(SqList &amp;L)&#123; L=(SqList)malloc(sizeof(SqList)); L-&gt;length=0; &#125; void CreatList(SqList &amp;L,char a[],int n)&#123; int i=0,k=0; while(i&lt;n) &#123; L-&gt;data[i]=a[i]; i++;k++; &#125; L-&gt;length=k;&#125;void DispList(SqList L)&#123; printf(“%c”,L-&gt;data[L-&gt;length-1]); for(int i=L-&gt;length-2;i&gt;=0;i–) printf(“ %c”,L-&gt;data[i]); printf(“\n”);&#125;int main()&#123; int n; char a[1000]; SqList *q; scanf(“%d”,&amp;n); getchar(); for(int i=0;i&lt;n;i++) &#123; scanf(“%c”,&amp;a[i]); &#125; InitList(q); CreatList(q,a,n); DispList(q); return 0;&#125; [943] 顺序表插入操作的实现思路题目描述python代码实现数据结构实现插入。。 传送门 描述 建立长度为n的顺序表，在指定的数据元素item之前插入数据元素data。如果指定的数据元素item不存在，则将data插入到顺序表的尾端。（数据类型为整型） 输入 第一行为顺序表的长度n；第二行为顺序表中的数据元素；第三行为指定的数据元素item；第四行为要插入的数据元素data； 输出 输出结果为顺序表中的数据元素。 样例输入12341010 20 30 40 50 60 70 80 90 1005055 样例输出110 20 30 40 55 50 60 70 80 90 100 1234567891011121314151617181920212223a = []n = int(input())a = list(map(int , raw_input().split()))x = int(input())y = int(input())k = -1def Findx(a,x): for i in range(len(a)): if(x == a[i]): global k #定义外部的k k = i return True return Falseif Findx(a,x) == True: a.insert(k,y) #根据下标插入else: a.append(y)for i in range(len(a)): print a[i], 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct&#123; elemtype data[1000]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist)malloc(sizeof(sqlist)); L-&gt;length=0;&#125;void creatlist(sqlist &amp;L,elemtype a[],int n)&#123; int i=0; while(i&lt;n) &#123; L-&gt;data[i]=a[i]; i++; &#125; L-&gt;length=n;&#125;void desplist(sqlist L)&#123; int i; //L-&gt;length++; printf(“%d”,L-&gt;data[0]); for(i=1;i&lt;=L-&gt;length;i++) &#123; printf(“ %d”,L-&gt;data[i]); &#125; printf(“\n”);&#125;void insertlist(sqlist &amp;L,elemtype x,int y)&#123; int z=0,i,k; for(i=0;i&lt;L-&gt;length;i++) &#123; if(x==L-&gt;data[i]) &#123; z=1; k=i; break; &#125; &#125; if(z==0) &#123; L-&gt;data[L-&gt;length]=y; &#125; else &#123; for(int j=L-&gt;length-1;j&gt;=k;j–) &#123; L-&gt;data[j+1]=L-&gt;data[j]; &#125; L-&gt;data[k]=y; &#125;&#125;int main()&#123; sqlist la; int n,x,y; int a[1000]; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); scanf(“%d%d”,&amp;x,&amp;y); initlist(la); creatlist(la,a,n); insertlist(la,x,y); desplist(la); return 0;&#125; [952] 单链表的插入操作的实现思路题目描述python代码实现数据结构实现链表插入操作。。 传送门 描述 建立长度为n的单链表，在第i个结点之前插入数据元素data。 输入 第一行为自然数n，表示链式线性表的长度；第二行为n个自然数表示链式线性表各元素值；第三行为指定插入的位置i；第四行为待插入数据元素data。 输出 指定插入位置合法时候，输出插入元素后的链式线性表的所有元素，元素之间用一个空格隔开。输入不合法，输出”error!”。 样例输入123451 2 3 4 536 样例输出11 2 6 3 4 5 12345678910111213141516171819202122232425import sysa = []n = int(input())a = list(map(int,raw_input().split()))x = int(input())y = int(input())c = 0if x == 0: a.insert(x,y)elif 0 &lt; x &lt;= len(a): a.insert(x - 1,y)elif x == len(a)+1: a.append(y)else: c = 1if c == 1: sys.stdout.write(“error!”)else: for i in range(len(a)): print a[i], 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL; &#125; void creatlist(linknode &amp;L,int a[],int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); s-&gt;data=a[i]; r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125;void desplist(linknode L)&#123; linknode p=L-&gt;next; while(p!=NULL) &#123; printf(“%d “,p-&gt;data); p=p-&gt;next; &#125;&#125;int listinsert(linknode &amp;L,int i,elemtype e)&#123; linknode p=L,s; int c=0; for(int j=0;j&lt;i-1&amp;&amp;p!=NULL;j++) &#123; p=p-&gt;next; &#125; if(p==NULL) c=1; else &#123; s=(linknode )malloc(sizeof(linknode)); s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125; return c;&#125;int main()&#123; linknode *la; int n,a[1000]; int i,e; int c; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); initlist(la); creatlist(la,a,n); scanf(“%d%d”,&amp;i,&amp;e); c=listinsert(la,i,e); if(c==1) printf(“error!”); else desplist(la); return 0;&#125; [953] 单链表的删除操作的实现思路题目描述python代码实现数据结构实现删除第i个结点之前的结点，即，当前结点的之前的第二个结点指向当前结点 传送门 描述 建立长度为n的单链表，删除第i个结点之前的结点。 输入 第一行为自然数n，表示链式线性表的长度；第二行为n个自然数表示链式线性表各元素值；第三行为指定的删除参数i。 输出 指定删除位置合法时候，输出删除元素后的链式线性表的所有元素，元素之间用一个空格隔开。输入不合法，输出”error!”。 样例输入12351 2 3 4 53 样例输出11 3 4 5 12345678910111213141516import sysa = []b = int(input())a = list(map(int, raw_input().split()))k = int(input())if k&gt;1 and k&lt;=b: a.pop(k-2) for i in range(len(a)): print a[i],else: sys.stdout.write(“error!”) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL;&#125;void creatlist(linknode &amp;L,int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%d”,&amp;s-&gt;data); r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125;void listdelete(linknode &amp;L,int i)&#123; int j=1; linknode p=L,q; while(j&lt;i-1&amp;&amp;p!=NULL) &#123; j++; p=p-&gt;next; &#125; q=p-&gt;next; p-&gt;next=q-&gt;next; free(q);&#125;void desplist(linknode L)&#123; linknode p=L-&gt;next; while(p!=NULL) &#123; printf(“%d “,p-&gt;data); p=p-&gt;next; &#125; //printf(“\n”);&#125;int main()&#123; linknode la; int n,i; scanf(“%d”,&amp;n); initlist(la); creatlist(la,n); scanf(“%d”,&amp;i); if(i&lt;=1||i&gt;n+1) printf(“error!”); else &#123; listdelete(la,i); desplist(la); &#125; return 0; &#125; [954] 单链表的链接思路题目描述python代码实现数据结构实现上个链表的尾指向下个链表的头 传送门 描述 建立长度为n的单链表A和长度为m的单链表B。编程实现将B表链接在A表的尾端，形成一个单链表A。数据类型指定为字符型。 输入 第一行为A表的长度n；第二行为A表中的数据元素;第三行为B表的长度m；第四行为B表中的数据元素。 输出 输出为链接好后的A表中的所有数据元素。 样例输入12344A B C D 61 2 3 4 5 6 样例输出1A B C D 1 2 3 4 5 6 123456789101112131415a = []n1 = int(input())a = list(raw_input().split())b = []n2 = int(input())b = list(raw_input().split())c = a + bfor i in range(len(c)): print c[i], 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef char elem;typedef struct node&#123; elem a; struct node next;&#125;linknode;void initlist (linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL;&#125;void creatlist(linknode &amp;L,int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%c”,&amp;s-&gt;a); getchar(); r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125;void desplist(linknode &amp;L)&#123; linknode p=L-&gt;next; while(p!=NULL) &#123; printf(“%c “,p-&gt;a); p=p-&gt;next; &#125;&#125;void combinelist(linknode &amp;l,linknode &amp;k)&#123; linknode p=l-&gt;next; while(p-&gt;next) &#123; p=p-&gt;next; &#125; p-&gt;next=k-&gt;next;&#125;int main()&#123; int m,n; while(~scanf(“%d”,&amp;m)) &#123; getchar(); linknode r,*s; initlist(r); creatlist(r,m); scanf(“%d”,&amp;n); getchar(); initlist(s); creatlist(s,n); combinelist(r,s); desplist(r); &#125; return 0;&#125; [955] 单链表上查找算法的实现思路题目描述python代码实现数据结构实现遍历，查找 传送门 描述 建立长度为n的单链表A和长度为m的单链表B。编程实现将B表链接在A表的尾端，形成一个单链表A。数据类型指定为字符型。 输入 第一行为链表的长度n；第二行为链表中的数据元素；第三行为要找的结点i。 输出 找到就输出ok，没找到就输出error。 样例输入123101 2 3 4 5 6 7 8 9 105 样例输出1ok 123456789import sysraw_input()if raw_input().find(raw_input()) != -1: sys.stdout.write(“ok”)else: sys.stdout.write(“error”) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef int elem;typedef struct node&#123; elem data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL; &#125; void creatlist(linknode &amp;L,int n) &#123; linknode r,s; r=(linknode )malloc(sizeof(linknode)); r=L; for(int i=0;i&lt;n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%d”,&amp;s-&gt;data); r-&gt;next=s; r=s; &#125; r-&gt;next=NULL; &#125; void findlist(linknode &amp;L,int e) &#123; linknode s=L-&gt;next; while(s!=NULL) &#123; if(s-&gt;data==e) &#123; printf(“ok”); return; &#125; s=s-&gt;next; &#125; if(s==NULL) printf(“error”); return; &#125; int main()&#123; int n,e; while(~scanf(“%d”,&amp;n)) &#123; linknode *la; initlist(la); creatlist(la,n); scanf(“%d”,&amp;e); findlist(la,e); &#125; return 0; &#125;#数组实现#include&lt;stdio.h&gt;int main()&#123; int n,x; int flag = 0; int a[1000]; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;a[i]); &#125; scanf(“%d”,&amp;x); for(int i=0;i&lt;n;i++) &#123; if(x == a[i]) &#123; flag = 1; break; &#125; &#125; if(flag == 1) printf(“ok”); else printf(“error”); return 0; &#125; [956] 约瑟夫问题思路题目描述python代码实现数据结构实现百度：约瑟夫环 传送门 描述 n个人围成一个圈，每个人分别标注为1、2、…、n，要求从1号从1开始报数，报到k的人出圈，接着下一个人又从1开始报数，如此循环，直到只剩最后一个人时，该人即为胜利者。例如当n=10,k=4时，依次出列的人分别为4、8、2、7、3、10，9、1、6、5，则5号位置的人为胜利者。给定n个人，请你编程计算出最后胜利者标号数。（要求用单循环链表完成。） 输入 第一行为人数n;第二行为报数k。 输出 输出最后胜利者的标号数。 样例输入1210 4 样例输出15 1234567891011import sysn = int(raw_input())m = int(raw_input())s = 0for i in range(2,n+1): s = (s + m) % ia = s + 1sys.stdout.write(‘%d’%a) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/#include&lt;stdio.h&gt;int main()&#123; int n,m,i,s=0; scanf(“%d%d”,&amp;n,&amp;m); for(i=2;i&lt;=n;i++) s=(s+m)%i; printf(“%d”,s+1); return 0; &#125; / #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct node&#123; int data; struct node next;&#125;linknode;int main()&#123; linknode L,r,s; L=(linknode )malloc(sizeof(linknode)); r=L; int n,i; int k; scanf(“%d%d”,&amp;n,&amp;k); for(i=1;i&lt;=n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); s-&gt;data=i; r-&gt;next=s; r=s; &#125; r-&gt;next=L-&gt;next; linknode *p; p=L-&gt;next; while(p-&gt;next!=p) &#123; for(i=1;i&lt;k-1;i++) &#123; p=p-&gt;next; &#125; p-&gt;next=p-&gt;next-&gt;next; p=p-&gt;next; &#125; printf(“%d”,p-&gt;data); return 0;&#125; [957] 逆置单链表思路题目描述python代码实现数据结构实现试试倒着输出 传送门 描述 建立长度为n的单链表，然后将其数据元素逆置，即第1个元素变为最后一个元素，第2个元素变为倒数第2个元素，以此类推，最后一个元素变为第1个元素。（处理的数据类型为字符型。必须使用链表完成。） 输入 第一行为链表长度n；第二行为链表中的n个数据元素的值。 输出 逆置后的原始的值。 样例输入1210ABCDEFGHIJ 样例输出1J I H G F E D C B A 1234567891011121314151617try: while True: n=int (input()) a = [] d = 0 for x in raw_input(): a.append(x) d = d+1 for i in range(d-1,-1,-1): print a[i],except EOFError: exit() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef char elem;typedef struct node&#123; elem data; struct node next;&#125;linknode;void initlist(linknode &amp;L)&#123; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL;&#125;void creatlist(linknode &amp;L,int n)&#123; linknode s; L=(linknode )malloc(sizeof(linknode)); L-&gt;next=NULL; for(int i=0;i&lt;=n;i++) &#123; s=(linknode )malloc(sizeof(linknode)); scanf(“%c”,&amp;s-&gt;data); s-&gt;next=L-&gt;next; L-&gt;next=s; &#125;&#125;void desplist(linknode &amp;L)&#123; linknode p=L-&gt;next; while(p-&gt;next!=NULL) &#123; printf(“%c “,p-&gt;data); p=p-&gt;next; &#125; &#125;int main()&#123; int n; scanf(“%d”,&amp;n); linknode la; initlist(la); creatlist(la,n); desplist(la); return 0;&#125; [960] 双向链表的操作问题思路题目描述python代码实现数据结构实现。。。 传送门 描述 建立一个长度为n的带头结点的双向链表，使得该链表中的数据元素递增有序排列。（必须使用双向链表完成，数据类型为整型。） 输入 第一行：双向表的长度；第二行：链表中的数据元素。 输出 输出双向链表中的数据元素的值。 样例输入12102 4 6 3 5 8 10 21 12 9 样例输出12 3 4 5 6 8 9 10 12 21 1234567891011a = []n = int(input())a = list(map(int, raw_input().split()))a.sort(reverse = False)for i in range(len(a)): print a[i], 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;typedef struct node&#123; int data; struct node prior; struct node next;&#125;linknode;void creatlist(linknode &amp;L,int a[],int n)&#123; linknode s,r; L=(linknode )malloc(sizeof(linknode)); r=L; r-&gt;prior=NULL; for(int i=0;i&lt;n;i++) &#123; r-&gt;data=a[i]; s=(linknode )malloc(sizeof(linknode)); r-&gt;next=s; s-&gt;prior=r; s-&gt;next=NULL; r=s; &#125; r-&gt;next=NULL;&#125;void paixu(linknode root )&#123; linknode p,q; p=root; q=root-&gt;next; while(p!=NULL) &#123; int t; q=root-&gt;next; while(q!=NULL) &#123; if(p-&gt;data&gt;q-&gt;data) &#123; t=p-&gt;data; p-&gt;data=q-&gt;data; q-&gt;data=t; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;“ “&lt;&lt;q-&gt;data&lt;&lt;endl; q=q-&gt;next; &#125; p=p-&gt;next; &#125;&#125;void display(linknode head)&#123; linknode p=head-&gt;next; while(p) &#123; cout&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl; &#125; void output(linknode root)&#123; linknode p=root; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;“ “; p=p-&gt;next; &#125;&#125;int main()&#123; linknode *root; int n,a[100]; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;a[i]); &#125; creatlist(root,a,n); paixu(root); output(root); return 0;&#125; [961] 进制转换问题思路题目描述python代码实现数据结构实现百度：十进制转二进制 传送门 描述 建立顺序栈或链栈，编写程序实现十进制数到二进制数的转换。 输入 输入只有一行，就是十进制整数。 输出 转换后的二进制数。 样例输入110 样例输出11010 1234567891011121314import sysdef Dec2Bin(dec): result = ‘’ if dec: result = Dec2Bin(dec // 2) return result + str(dec % 2) else: return resultn = int(raw_input())sys.stdout.write(Dec2Bin(n)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define max 100typedef int elemtype;typedef struct&#123; elemtype data[max]; int top;&#125;sqstack;void initstack(sqstack &amp;s)&#123; s=(sqstack )malloc(sizeof(sqstack)); s-&gt;top=-1;&#125;void push(sqstack &amp;s,elemtype e)&#123; s-&gt;top++; s-&gt;data[s-&gt;top]=e;&#125;void pop(sqstack &amp;s,elemtype &amp;e)&#123; e=s-&gt;data[s-&gt;top]; s-&gt;top–;&#125;int empty(sqstack &amp;s)&#123; return (s-&gt;top==-1);&#125;void conversion(int n)&#123; int e; sqstack p=(sqstack *)malloc(sizeof(sqstack)); initstack(p); while(n) &#123; push(p,n%2); n=n/2; &#125; while(!empty(p)) &#123; pop(p,e); printf(“%d”,e); &#125;&#125;int main()&#123; int n; scanf(“%d”,&amp;n); conversion(n); return 0;&#125; [963] 小偷的背包思路题目描述python代码实现数据结构实现背包 传送门 描述 设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…，wn。问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。如果有满足条件的选择，则此背包有解，否则此背包问题无解。 输入 第一行为物品重量S（整数）；第二行为物品数量n，第三行为n件物品的重量的序列。 输出 有解就输出”yes!“，没有解就输出”no!“。 样例输入1232051 3 5 7 9 样例输出1yes! 123456789101112131415161718192021222324import sysdef pack(weight,amonut): if weight == 0: return 1 if weight &lt; 0 or (weight &gt; 0 and amonut &lt; 1): return 0 if pack(weight - get_weight[amonut - 1],amonut - 1 ): return 1 else: return pack(weight,amonut - 1)get_weight = []weight = int(input())amount = int(input())get_weight = list(map(int,raw_input().split()))if pack(weight, amount): sys.stdout.write(“yes!”)else: sys.stdout.write(“no!”) 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int get_weight[100];int pack(int weight,int amonut)&#123; if(weight==0) &#123; return 1; &#125; if(weight&lt;0||(weight&gt;0&amp;&amp;amonut&lt;1)) &#123; return 0; &#125; if(pack(weight-get_weight[amonut-1],amonut-1)) &#123; return 1; &#125; else return pack(weight,amonut-1); &#125;int main()&#123; int weight,amonut; scanf(“%d%d”,&amp;weight,&amp;amonut); for(int i=0;i&lt;amonut;i++) &#123; scanf(“%d”,&amp;get_weight[i]); &#125; if(pack(weight,amonut)) printf(“yes!”); else printf(“no!”); return 0;&#125; [966] 打印杨辉三角形思路题目描述python代码实现数据结构实现打印。 传送门 描述 杨辉三角形具有如下特征： 1、每行数字左右对称，由1开始逐渐变大，然后变小，回到1。 2、第n行的数字个数为n个。 3、第n行数字和为2^(n－1)。 4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。 5、将第2n+1行第1个数，跟第2n+2行第3个数、第2n+3行第5个数……连成一线，这些数的和是第2n个斐波那契数。将第2n行第2个数，跟第2n+1行第4个数、第2n+2行第6个数……这些数之和是第2n-1个斐波那契数。 6、第n行的第1个数为1，第二个数为1×(n-1)，第三个数为1×(n-1)×（n-2）/2，第四个数为1×(n-1)×（n-2）/2×（n-3）/3…依此类推。例如7阶杨辉三角形如下： 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 要求：利用循环队列，编程实现打印杨辉三角形。（n在0-12之间取值） 输入 输入要打印的杨辉三角形的阶n。 输出 打印出n阶杨辉三角形。 样例输入17 样例输出123456711 11 2 11 3 3 11 4 6 4 11 5 10 10 5 11 6 15 20 15 6 1 12345678910111213def disp(i, j): if j == 1 or j == i: return 1 else: return disp(i - 1, j - 1) + disp(i - 1, j)n = int(input())for i in range(1,n + 1): for j in range(1, i+1): print disp(i,j), print “\n”, 12345678910111213141516171819202122#include&lt;stdio.h&gt;int disp(int i,int j)&#123; if((j==1)||(j==i)) return 1; else return (disp(i-1,j-1)+disp(i-1,j));&#125;int main()&#123; int i,j,n; scanf(“%d”,&amp;n); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;i+1;j++) &#123; printf(“%d “,disp(i,j)); &#125; printf(“\n”); &#125; return 0;&#125; [1027] 舞伴问题思路题目描述python代码实现数据结构实现循环 传送门 描述 假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。要求编写程序实现舞伴问题。 输入 输入一共5行，第一行是男生人数m；第二行依次是男生的姓名；第三行是女士的人数n；第四行依次是女士的姓名；第五行是跳舞的轮数。 输出 配对的男士和女士的姓名。 样例输入1234565A B C D E3F G H2 样例输出1B G 12345678910111213import sysn = int(input())a = list(raw_input().split())m = int(input())b = list(raw_input().split())k = int(input())sys.stdout.write(‘%c %c’%(a[(k-1)%n], b[(k-1)%m])) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; char data[100]; int front,rear;&#125;queue;void initqueue(queue &amp;q)&#123; q=(queue )malloc(sizeof(queue)); q-&gt;front=q-&gt;rear=0;&#125;void inqueue(queue &amp;q,int max)&#123; char e; for(int i=0;i&lt;max;i++) &#123; getchar(); scanf(“%c”,&amp;e); q-&gt;data[q-&gt;rear]=e; q-&gt;rear=(q-&gt;rear+1)%max; &#125;&#125;void print(queue &amp;q1,queue &amp;q2,int time,int max1,int max2)&#123; for(int i=0;i&lt;time-1;i++) &#123; q1-&gt;front=(q1-&gt;front+1)%max1; q2-&gt;front=(q2-&gt;front+1)%max2; &#125; printf(“%c %c”,q1-&gt;data[q1-&gt;front],q2-&gt;data[q2-&gt;front]);&#125;int main()&#123; queue la,*lb; int max1,max2,time; initqueue(la); initqueue(lb); scanf(“%d”,&amp;max1); inqueue(la,max1); scanf(“%d”,&amp;max2); inqueue(lb,max2); scanf(“%d”,&amp;time); print(la,lb,time,max1,max2); return 0;&#125; [1037] 集合的并运算的实现思路题目描述python代码实现数据结构实现并 传送门 描述 假设有两个集合 A 和 B 分别用两个线性表 LA 和 LB 表示，即线性表中的数据元素即为集合中的成员。编程实现集合A和集合B的并运算。 输入 第一行为集合A的数据元素个数n 第二行输入n个集合A的数据元素 第三行为集合B的数据元素的个数； 第四行输入m个集合B的数据元素。 输出 第一行为A和B的并集. 样例输入1234580 5 6 3 8 7 9 1071 3 4 7 8 9 5 样例输出10 5 6 3 8 7 9 10 1 4 1234567891011121314151617181920a = []n1 = int(input())a = list(map(int,raw_input().split()))b = []n2 = int(input())b = list(map(int,raw_input().split()))for i in range(len(a)): print a[i],for i in range(len(b)): k = 0 for j in range(len(a)): if b[i] == a[j]: k = 1 if k == 0 : print b[i], 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct &#123; int data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;l)&#123; l=(sqlist )malloc(sizeof(sqlist)); l-&gt;length=0;&#125;void creatlist(sqlist &amp;l,int n)&#123; for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;l-&gt;data[i]); &#125; l-&gt;length=n;&#125;void combinelist(sqlist l,sqlist s)&#123; for(int i=0;i&lt;l-&gt;length;i++) &#123; printf(“%d “,l-&gt;data[i]); &#125; for(int i=0;i&lt;s-&gt;length;i++) &#123; int k=0; for(int j=0;j&lt;l-&gt;length;j++) &#123; if(l-&gt;data[j]==s-&gt;data[i]) &#123; k=1; &#125; &#125; if(k==0) printf(“%d “,s-&gt;data[i]); &#125;&#125;int main()&#123; sqlist la,*lb; int n,m; initlist(la); initlist(lb); scanf(“%d”,&amp;n); creatlist(la,n); scanf(“%d”,&amp;m); creatlist(lb,m); combinelist(la,lb); return 0;&#125; [1038] 顺序表中重复数据的删除思路题目描述python代码实现数据结构实现查重 传送门 描述 将存储在顺序表中的长度为n的线性表中指定的数据全部删除。 输入 第一行为顺序表的长度n； 第二行为顺序表中的数据元素； 第三行为指定要删除的元素值。 输出 如果表不空，输出删除指定值后的线性表；如果删除后表空，则输出-1。 样例输入1234811 22 33 44 44 55 44 6644 样例输出111 22 33 55 66 12345678910111213141516import sysa = []n = int(input())a = list(map(int,raw_input().split()))x = int(input())b = 0for i in range(len(a)): if x != a[i]: print a[i], b = 1if b == 0: sys.stdout.write(“-1”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct&#123; int data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;l)&#123; l=(sqlist )malloc(sizeof(sqlist)); l-&gt;length=0;&#125;void creatlist(sqlist &amp;l,int n)&#123; for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;l-&gt;data[i]); &#125; l-&gt;length=n;&#125;void delelist(sqlist l,int e)&#123; int flag=0; for(int i=0;i&lt;l-&gt;length;i++) &#123; if(l-&gt;data[i]!=e) &#123; printf(“%d “,l-&gt;data[i]); flag=1; &#125; &#125; if(flag==0) printf(“-1”);&#125;int main()&#123; sqlist *la; int n,e; scanf(“%d”,&amp;n); initlist(la); creatlist(la,n); scanf(“%d”,&amp;e); delelist(la,e); return 0;&#125; [1044] 顺序栈基本操作的实现思路题目描述python代码实现数据结构实现入栈，出栈，栈顶 传送门 描述 编程实现顺序栈的初始化、入栈、出栈、取栈顶元素和计算栈中元素个数等基本操作。 输入 第一行为入栈元素的个数； 第二行依次为入栈的元素； 出栈操作的次数n. 输出 输出n次出栈后的栈顶元素值。如果是空栈，输出-1. 样例输入12341 2 3 42 样例输出12 1234567891011121314151617import sysn = int(input())a = list(map(int, raw_input().split()))m = int(input())while m: a.pop() m -= 1if len(a) is not 0: sys.stdout.write(‘%d’%a[len(a)-1])else: sys.stdout.write(“-1”) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data[1000]; int top;&#125;sqstack;void initstack(sqstack &amp;s)&#123; s=(sqstack )malloc(sizeof(sqstack)); s-&gt;top=-1;&#125;void push(sqstack &amp;s,int e)&#123; s-&gt;top++; s-&gt;data[s-&gt;top]=e;&#125;bool stackempty(sqstack s)&#123; return s-&gt;top==-1;&#125;bool pop(sqstack &amp;s,int &amp;e)&#123; if(s-&gt;top==-1) return 0; e=s-&gt;data[s-&gt;top]; s-&gt;top–; return true;&#125;int main()&#123; sqstack s; int temp,e; initstack(s); int n,a; scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;a); push(s,a); &#125; int flag=0; scanf(“%d”,&amp;temp); for(int i=0;i&lt;=temp;i++) &#123; pop(s,e); &#125; if(temp&gt;=n) printf(“-1”); else if(stackempty) &#123; printf(“%d”,e); &#125; return 0;&#125; [1045] 集合的交运算的实现思路题目描述python代码实现数据结构实现交运算 传送门 描述 假设有两个集合 A 和 B 分别用两个线性表 LA 和 LB 表示，即线性表中的数据元素即为集合中的成员。编程实现集合A和集合B的交运算。 输入 第一行为集合A的数据元素个数n;第二行输入n个集合A的数据元素 ;第三行为集合B的数据元素的个数；第四行输入m个集合B的数据元素 输出 A和B的交集 样例输入123480 5 6 3 8 7 9 1071 3 4 7 8 9 5 样例输出15 3 8 7 9 12345678910111213141516a = []n1 = int(input())a = list(map(int,raw_input().split()))b = []n2 = int(input())b = list(map(int,raw_input().split()))for i in range(len(a)): for j in range(len(b)): if a[i] == b[j]: print a[i], 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct &#123; elemtype data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;l)&#123; l=(sqlist )malloc(sizeof(sqlist)); l-&gt;length=0;&#125;void creatlist(sqlist &amp;l,int n)&#123; for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;l-&gt;data[i]); &#125; l-&gt;length=n;&#125;void holist(sqlist &amp;l,sqlist &amp;s)&#123; for(int i=0;i&lt;s-&gt;length;i++) &#123; for(int j=0;j&lt;l-&gt;length;j++) &#123; if(l-&gt;data[j]==s-&gt;data[i]) printf(“%d “,l-&gt;data[i]); &#125; &#125;&#125;int main()&#123; sqlist la,*lb; int m,n; initlist(la); initlist(lb); scanf(“%d”,&amp;m); creatlist(la,m); scanf(“%d”,&amp;n); creatlist(lb,n); holist(la,lb); return 0;&#125; [1102] 顺序表上数据的划分问题的实现思路题目描述python代码实现数据结构实现比较 传送门 描述 建立一个顺序表L，然后以第一个为分界，将所有小于等于它的元素移到该元素的前面，将所有大于它的元素移到该元素的后面。 输入 顺序表长度n；顺序表中的数据元素。 输出 移动后的数据元素。 样例输入121032 5 22 43 23 56 54 57 11 25 样例输出125 11 23 22 5 32 43 56 54 57 1234567891011121314151617n = int(input())a = list(map(int, raw_input().split()))g = a[0]for i in range(1, len(a)): if a[i] &lt; g: k = a[i] a.pop(i) a.insert(0, k)for k in a: print k, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist )malloc(sizeof(sqlist)); L-&gt;length=0;&#125;void creatlist(sqlist &amp;L,int n)&#123; L=(sqlist )malloc(sizeof(sqlist)); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;L-&gt;data[i]); &#125; L-&gt;length=n;&#125;void movlist(sqlist &amp;L)&#123; int p=L-&gt;data[0]; for(int i=L-&gt;length-1;i&gt;=0;i–) &#123; if(L-&gt;data[i]&lt;=p) &#123; printf(“%d “,L-&gt;data[i]); &#125; else continue; &#125; for(int i=0;i&lt;L-&gt;length;i++) &#123; if(L-&gt;data[i]&gt;p) &#123; printf(“%d “,L-&gt;data[i]); &#125; else continue; &#125;&#125;int main()&#123; sqlist la; int n; initlist(la); scanf(“%d”,&amp;n); creatlist(la,n); movlist(la); return 0;&#125; [1103] 删除顺序表中指定区间的数据思路题目描述python代码实现数据结构实现比较、删除 传送门 描述 建立顺序表L，将指定区间的数据从顺序表中删除。假设指定区间是合法数据，无序做合法性判断。测试数据为整型。 输入 第一行是表长n；第二行是表中数据元素。 输出 删除以后的顺序表中的数据元素。 样例输入1231022 32 11 23 43 59 17 65 45 5710 20 样例输出122 32 23 43 59 65 45 57 12345678910111213a = []n = int(input())a = list(map(int,raw_input().split()))x = list(map(int,raw_input().split()))for i in range(len(a)): if a[i] &lt; x[0] or a[i] &gt; x[1]: print a[i], 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int elemtype;typedef struct node&#123; elemtype data[100]; int length;&#125;sqlist;void initlist(sqlist &amp;L)&#123; L=(sqlist )malloc(sizeof(sqlist)); L-&gt;length=0;&#125;void creatlist(sqlist &amp;L,int n)&#123; L=(sqlist )malloc(sizeof(sqlist)); for(int i=0;i&lt;n;i++) &#123; scanf(“%d”,&amp;L-&gt;data[i]); &#125; L-&gt;length=n;&#125;void movlist(sqlist &amp;L,int a,int b)&#123; int p=L-&gt;data[0]; for(int i=0;i&lt;L-&gt;length;i++) &#123; if(L-&gt;data[i]&lt;a||L-&gt;data[i]&gt;b) printf(“%d “,L-&gt;data[i]); &#125;&#125;int main()&#123; sqlist la; int n; int a,b; initlist(la); scanf(“%d”,&amp;n); creatlist(la,n); scanf(“%d%d”,&amp;a,&amp;b); movlist(la,a,b); return 0;&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>题解~</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习（一）：KNN算法的实现]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AKNN%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[##描述百度百科 ##算法实现原理： 1.计算已知类别数据集中的点与当前点之间的距离; 2.按照距离递增次序排序； 3.选取与当前点距离最小的k个点； 4.确定前k个点所在类别的出现频率； 5.返回前k个点所出现频率最高的类别作为当前点的预测分类。 ##算法实现： ###数据集的建立及python代码的实现：123456789import numpy as npfrom numpy import *import operator#训练集def creatDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = [&apos;A&apos;,&apos;A&apos;,&apos;B&apos;,&apos;B&apos;] return group, labels ####运行结果： 如下图： ###KNN算法的实现：12345678910111213141516171819202122232425262728293031#KNN分类# inX 用于分类的数据（即测试集）# dataSet 用于训练的数据（即测试集）# labels 分类的标签# k KNN算法中 K 的值def classify(inX,dataSet,labels,k): #计算距离 dataSetSize = dataSet.shape[0] #返回dataSet的行数 diffMat = np.tile(inX, (dataSetSize,1)) - dataSet #inX 在（行向量方向上重复，列向量方向上重复）次数 sqDiffMat = diffMat**2 #二维特征相减后平方 sqDistances = sqDiffMat.sum(axis=1) #相减平方再相加 distances = sqDistances**0.5 #再开方 #排序（从小到大） sortedDistIndices = distances.argsort() #排序并返回下标 classCount = &#123;&#125; #定义一个记录类别次数的字典 for i in range(k): voteIlabel = labels[sortedDistIndices[i]] #取出前K个元素的类别 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #计算类别的次数# key=operator.itemgetter(1)根据字典的值进行排序# key=operator.itemgetter(0)根据字典的键进行排序# reverse降序排序字典 sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True) # 降序排序 return sortedClassCount[0][0] ####测试结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Counterfeit Dollar(枚举)]]></title>
    <url>%2F2018%2F07%2F07%2FCounterfeit-Dollar-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[描述传送门 Sally Jones has a dozen Voyageur silver dollars. However, only eleven of the coins are true silver dollars; one coin is counterfeit even though its color and size make it indistinguishable from the real silver dollars. The counterfeit coin has a different weight from the other coins but Sally does not know if it is heavier or lighter than the real coins.Happily, Sally has a friend who loans her a very accurate balance scale. The friend will permit Sally three weighings to find the counterfeit coin. For instance, if Sally weighs two coins against each other and the scales balance then she knows these two coins are true. Now if Sally weighsone of the true coins against a third coin and the scales do not balance then Sally knows the third coin is counterfeit and she can tell whether it is light or heavy depending on whether the balance on which it is placed goes up or down, respectively.By choosing her weighings carefully, Sally is able to ensure that she will find the counterfeit coin with exactly three weighings. input The first line of input is an integer n (n &gt; 0) specifying the number of cases to follow. Each case consists of three lines of input, one for each weighing. Sally has identified each of the coins with the letters A–L. Information on a weighing will be given by two strings of letters and then one of the words “up”, “down”, or “even”. The first string of letters will represent the coins on the left balance; the second string, the coins on the right balance. (Sally will always place the same number of coins on the right balance as on the left balance.) The word in the third position will tell whether the right side of the balance goes up, down, or remains even. output For each case, the output will identify the counterfeit coin by its letter and tell whether it is heavy or light. The solution will always be uniquely determined. 样例12345678910input:1 ABCD EFGH even ABCI EFJK up ABIJ EFGH even output:K is the counterfeit coin and it is light. 题意理解+思路题意理解 题意说一共有12个硬币，其中有一个是假币，不知道是重还是轻，一共可以称量3次来寻找假币。输入第一行是n（n&gt;0），指需要测试的案例数。每个案例由3行输入，用A-L来表示硬币。第一串字母代表天平左边，第二串代表天平右边，第三串字母由 even up down 来分别表示保持平衡、天平右侧上升、天平右侧下降。要求找出假币所代表的的字母并告知是重还是轻。 思路 开12个数组代表A-L，并赋初值为0，若天平平衡，则将左右的所有字母对应的数组都赋值为一个固定的数，若不平衡，则首先除去固定数的数组（数字固定，表示是真币）然后将重的一侧加一，轻的一侧减一。最后遍历数组寻找出绝对值最大的数就是假币，因为这个数字是被怀疑次数最多的。如果除去绝对值为正，则为重，否则为轻。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt; int main()&#123; int n,k,i,t,len,max; char s1[13],s2[13],temp[10]; int a[12]; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; memset(a,0,sizeof(a)); for(t=0;t&lt;3;t++) &#123; scanf(&quot;%s%s%s&quot;,s1,s2,temp); len=strlen(s1); //两边个数肯定相等，所以两边长度也一样,不能只看样例便觉得一定是4而忽略这一步，否则会 WA if(strcmp(temp,&quot;even&quot;)==0) &#123; for(i=0;i&lt;len;++i) &#123; a[s1[i]-&apos;A&apos;]=10; //说明两边都为真，将标记数组置为10（10为自己设置的固定的数，但不能过小否则会错。） a[s2[i]-&apos;A&apos;]=10; &#125; &#125; else if(strcmp(temp,&quot;up&quot;)==0)//说明左边重 &#123; for(i=0;i&lt;len;++i) &#123; if(a[s1[i]-&apos;A&apos;]!=10) ++a[s1[i]-&apos;A&apos;]; //左边加一 if(a[s2[i]-&apos;A&apos;]!=10) --a[s2[i]-&apos;A&apos;]; //右边减一 &#125; &#125; else &#123; for(i=0;i&lt;len;++i) //说明右边重 &#123; if(a[s1[i]-&apos;A&apos;]!=10) --a[s1[i]-&apos;A&apos;]; //左边减一 if(a[s2[i]-&apos;A&apos;]!=10) ++a[s2[i]-&apos;A&apos;]; //右边加一 &#125; &#125; &#125; max=0; k=0; for(i=0;i&lt;12;++i) &#123; if(a[i]==10) continue; if(max&lt;=abs(a[i])) &#123; max=abs(a[i]); k=i; &#125; &#125; if(a[k]&gt;0) //去绝对值后的符号决定轻重。 printf(&quot;%c is the counterfeit coin and it is heavy.\n&quot;,&apos;A&apos;+k); else printf(&quot;%c is the counterfeit coin and it is light.\n&quot;,&apos;A&apos;+k); &#125; return 0; &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在我搭建博客中所遇到的坑]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%9C%A8%E6%88%91%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[遇到的第一个坑hexo不显示 在安装hexo的过程中输入 hexo -v 查看hexo安装版本的时候，没有显示hexo的版本。 安装完毕后，理应显示的图为： 然而我的显示图为： 解决办法： 原理：因为需要git bash到你所创建的子文件中，而不是上一层文件中，在上一层文件中不会显示你所安装过的hexo的版本。 遇到的第二个坑背景虚化 在我搭建博客过程中，发现背景要么极暗要么极白，很难调节，加上什么背景图片都很难看清字体。起初我想要更改字体的颜色来弥补，后来发现情况不止如此，问了大佬以后才知道可以去更改一下背景，百度半天虚化背景发现这个背景，没什么进展，问了一个前端大佬，才修改完毕，具体如下:博客根目录 themes\next\source\css_custom这个文件下的custom.styl文件中修改如下：。 嗯~其他坑还在踩，欢迎投稿。。]]></content>
      <categories>
        <category>-解决问题</category>
      </categories>
      <tags>
        <tag>-问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Happy Birthday]]></title>
    <url>%2F2018%2F06%2F27%2FHappy-Birthday%2F</url>
    <content type="text"><![CDATA[记陪你的第一次生日 2017年6月。 回想起高三那年结束前，你我是同桌，你跟我说快过生日了，但却是高考以后。我就想提前送你一些礼物，无他，只因为你是我同桌。 2017年7月。 后来发生了一些很奇妙的事，渐渐的越来越熟，也就是越来越熟。那年六月，一起高考，那年七月，各奔东西。 2017年8月。 一些事就是缘分问题，也确实是很难的。抉择问题。反正是一起来四川了。挺好的。这个月记得的好像是开学。嗯，对，就是开学。 2017年9月。 这个月印象还是蛮不错的，去了一次成都，第一次去呐，还算可以，问了路程，问了方向，问了倒转车，说走就走了。。 2017年10月。 十月一开学，放假7天，没在学校，去成都浪了。见了三年不见的好友，一起大概的走了成都。反正哪里挤去了哪里，反正缘分这东西，说不清楚。 2017年11月。 这个月没什么太大的波浪，仍然保持着一个月或者两周去看一次的习惯。过的波澜不惊。除了复习备考，好像还有美食节？ 2017年12月。 这个月还凑合，月初啊，月末啊啥的你就过来了，只是来的好像不是时候，完美错过了东八舞池和元旦晚会呐，真是有点遗憾。 2018年1月。 主要在准备考试和考完试的颓废中生活。还行吧，就这样，不过还发现了美食，等着带你来吃。17号回去，一起坐高铁。真是不错。 2018年2月。 这个月就是在家嘛，打游戏多了，你还是挺生气的。14号那天，之前，做了个小视频，送给你了，也就是个小视频呐。凑合。。地址的话，在空间吧。 2018年3月。 开学的日子，去接你，结果你手机被偷了，虽然事情解决了，可是还是心有余悸呐。以后还是要万分小心。不过月底你还是过来陪我耍了两天。开森。 2018年4月。 清明节的时候过去了，我还真的错不过每次的放假呐。一有时间就还是会去，或许就是单纯想去吧。这个月好像实现了半天来回成都？？ 2018年5月。 劳动节的时候去了，也很快就回来了，前一两天，还在学校转悠，第三天还是去了。去了之前没去的地方，还好天气不错。 2018年6月。 因为端午节要考试呐，这个月还是复习备考的一个月，儿童节还是忍住了没去，因为第二天考试。。也在这个月吧，迎来了你的生日呐，还是选择去吧，无他，因为你是我女朋友。 2018年。。。 故事还在继续，那句话咋说来着，我有故事，你有酒吗？]]></content>
      <categories>
        <category>-杂记</category>
      </categories>
      <tags>
        <tag>-life</tag>
      </tags>
  </entry>
</search>
